import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 다이나믹 프로그래밍
    # -> 메모리를 사용해서 수행시간 효율성을 비약적으로 향상
    # -> 이미 계산결과를 메모리에 저장하여 다시 계산하지 않도록 한다.
    # -> 탑다운 vs 보텀업 2가지 방법을 가진다.
    # -> 동적 계획법이라 부른다. 동적 -> 프로그램 실행 도중이란 의미이나. 다이나믹프로그래밍에서의 동적은 의미없다.
    ## 특정조건
    # (1) 최적 부분구조 -> 큰 문제를 작은 문제로 나누기
    # (2) 중복되는 부분 문제 -> 여러번 등장하는 작은 문제를 한번만 계산
    # => 점화식 + 초항들 => 트리형태로 만들 수 있고, 재귀문제로 바로 풀 수 도 있다. => 그러나 재귀호출은 동일한 부분문제를 매번 호출하게 된다.
    # => 배열이나 리스트(table)에 저장해서 사용한다.

    def fibo(x):
        if x == 1 or x == 2:
            return 1
        return fibo(x - 1) + fibo(x - 2)  # 2개의 node를 낸 뒤, 집계하는 꼬리재귀


    print(fibo(4))

    # 재귀로 해결하면, 지수시간 복잡도를 가진다. => f(2)가 여러번 호출되어 계산한다. => 중복 부분문제발생!!!!!
    # => O(2^N) 1개 요소마다 2개식 node가 뻗치는 구조.
    # => 한번 해결한 문제는 별도의 메모리공간에 저장해놔야한다.

    # 조건확인 (1) 최적 부분구조 -> 큰 문제를 작은 문제로 나눌 수 있다. (점화식)
    #         (2) 중복되는 부분문제 -> 동일한 작은 문제가 여러번 등장한다. (점화식의 구조가 인접재귀를 호출할때마다 겹친다)
    # [1] 탑다운(하향식) by 재귀 + 메모이제이션
    # -> 한번 구한 부분문제를 그대로 사용한다 -> 배열(table)에 값을 기록하므로 캐싱(Caching)이라고도 한다
    # [2] 보텀업(상향식) by 반복문 + dp테이블(배열)
    # => 시간복잡도가 O(N)으로 줄어든다 (dp테이블에 저장된 것을 바로반환하는 경우, 재귀를 안타고 바로 반환하므로 시간복잡도X)

    ## 피보나치를 탑다운 by 재귀+메모이제이션으로 해결하기
    # (1) 탑다운by 재귀+메모이제이션으로 사용할 배열 선언
    d = [0] * 100  # 0~99까지 숫자를 index에 매핑

    # (2) 탑다운by 재귀+메모이제이션의 재귀함수 정의
    def fibo(x):
        if x == 1 or x == 2: # 종착역은 동일하나
            return 1
        # (3) 현재x에 대해 이미 해결했는지( not 0) dp테이블에서 확인 후 바로 반환한다.
        if d[x]:
            return d[x]
        # (4) 계산한적 없다면, 계산후 테이블 업데이트(저장)까지 하고 반환한다.
        # return fibo(x - 1) + fibo(x - 2)
        d[x] = fibo(x - 1) + fibo(x - 2)
        return d[x]

    print(fibo(99))

    ## 피보나치를 보텀업 by 반복문 + 초항적힌 dp테이블로 해결
    # (1) dp테이블 0으로 초기화
    d = [0] * 100
    # (2) dp테이블에 초기항 입력
    d[1], d[2] = 1, 1
    # (3) 반복문을 통해 초기항다음부터 마지막까지 점화식을 통해 dp테이블을 채우기
    for i in range(3, 99 + 1):
        d[i] = d[i-1] + d[i-2]
    print(d[99])

    # 분할정복 -> 최적 부분구조를 가지는 점화식의 형태이다.
    # + 부분 문제의 중복 -> 다이나믹프로그래밍으로서 탑다운by재귀+메모 / 보텀업by반복문+초기항적인 dp테이블로 시간복잡도를 낮춘다.
    # => 분할정복의 대표예시 퀵정렬은, 부분문제의 중복이 없다
    # => pivot이 자리 잡으면, 위치가 바뀌지 않는다. 점점 절반씩 쪼갠 node가 뻣어나가지만, 중복될 일이 없이 쪼개진다
    #    점화식이 값에 따라 중복되지 않음.

    ## 접근방법
    # 그리디/구현/완탐 -> 완탐시 시복이 너무 든다 -> 분할정복 ->  다이나믹 고려



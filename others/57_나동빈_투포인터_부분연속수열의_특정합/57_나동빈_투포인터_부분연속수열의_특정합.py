import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 투 포인터 : 리스트에 순차적으로 순차적 접근시, 2개의 점의 위치를 기록하면서 처리
    # ex> 2, 3, 4, 5,6, 7 -> 2번부터 7번까지의 학생 -> [시작점/끝점을 하나씩 명시]하여 [특정범위를 지칭]하여 처리
    # -> list에 담긴 데이터에서 순차적 접근시, 시작점+끝점 2개의 점으로 접근할 데이터의 범위를 표현할 수 있다.

    ## 예시: 특정한 합을 가지는 부분 연속 수열 찾기
    # -> N개 자연수로 구성된 수열
    # -> 합이 M인 부분 연속 수열의 갯수를 구해봇요
    # -> 수행시간 제한은 O(N)입니다 => 데이터갯수만큼 선형적으로 탐색해야한다.
    # => 완전탐색시 1 -> 2345 탐색 2-> 325 탐색 한다면, O(N제곱)이 걸릴 것이다.
    # 12325 -> 23 32 5

    # => [부분 연속수열]은 투포인터로 해결할 수 있다.
    # my) 교환법칙성립하는, 일반 부분집합 구한다면? -> 양 끝에서 투포인터 시작
    #     교환법칙성립하는, 연속수열을 구한다면? -> 왼쪽 끝에서 2개의 투포인터 시작(end도)
    # (1) start/end를 0번째 인덱스에서 시작한다.
    # (2) 현재 부분합을 보고, M이라면 카운팅
    # (3) m보다 작으면 end를 증가 => [end를 증가시키면 합을 구하는 범위가 증가하는 것]
    # (4) m보다 크거나 같으면 start를 증가 => [start를 증가시키면, 합을 구하는 범위가 좁아지는 것]
    # (5) 2~4번 반복
    # => my) 연속하는 부분수열을 범위를, 0번째원소에 2포인터로를 놓고, 조절하면서 만들어나간다.
    #   ↓
    #   1 2 3 2 5
    #   ↑             부분합 1

    #   ↓
    #   1 2 3 2 5
    #     ↑           부분합 3

    #   ↓
    #   1 2 3 2 5
    #       ↑          부분합 6 => start를 증가시켜, 합산의 범위를 좁혀, 부분합을 줄인다.

    #     ↓
    #   1 2 3 2 5
    #       ↑          부분합 5 => M이랑 같을 때도 (M이상이면) start를 이동시킨다.
    #                             해를 1개 찾았을 때, start를 이동시켜, 새로운 해를 구하게 된다.

    #       ↓
    #   1 2 3 2 5
    #       ↑          부분합 3

    #       ↓
    #   1 2 3 2 5
    #         ↑       부분합 5

    #         ↓
    #   1 2 3 2 5
    #         ↑       부분합 5

    #         ↓
    #   1 2 3 2 5
    #           ↑     부분합 7

    #           ↓
    #   1 2 3 2 5
    #           ↑     부분합 5

    data = [1, 2, 3, 2, 5]
    m = 5  # 부분연속수열이 만족해야하는 부분합

    # (1) start, end가 둘다 움직이는 상황에서 while로 각각 움직이기 보다는
    # -> start는 어차피 0부터 n-1까지 for문으로 증가시키며
    # -> end만 0으로 초기화해놓고, 조건에 맞을때까지 whlie로 움직인다.
    end = 0
    count = 0
    interval_sum = 0
    for start in range(len(data)):
        # (2) start에 대하여, end를 부분합이 m보다 크거나 같아질때까지 이동시킨다.
        # -> while문으로 인덱스 이동시, 인덱스범위는 항상 맨첨에 확인해준다.
        # -> 원하는 조건 interval_sum >= m이 나올때가지 end를 1씩 증가시킨다.
        while end < len(data) and interval_sum < m:
            interval_sum += data[end]
            end += 1

        # (3) interval_sum >= m인 상황에서, m이랑 같을때만 카운팅을 해준다.
        # -> 뒤에 interval_sum >= m 의 상황이라면, start가 +1 증가하니,
        if interval_sum == m:
            count += 1
        # (4)  다음 루프 전에, 부분연속수열에서 빠지는 현재 start위치의 값은 부분수열에서 빼준다.
        # -> 슬라이딩 윈도우처럼, 앞에 것 1개는 빼줘야한다.
        interval_sum -= data[start]

    print(count)

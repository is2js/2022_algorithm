import sys

input = sys.stdin.readline


def solve(cnt, used, val):
    # [3] stack결정변수로서 0에서 2로 업데이트된 순간, 종료하고 중간계산결과를 반환한다
    if cnt == 2:
        return val

    # [7] 자식재귀가 반환해주는 값은, 최종완성 값
    #     첫호출시 자신의처리가 없다면, 자식들반환값을 aggregation해주는 역할을 생각한다.
    ret = 0 #  ret = max(, )업데이트되는 업데이트변수의 초기값은 [하한]이다.
    # [4] 동적트리순회는, 전역배열의 갯수N만큼 돌면서 다 시도하면서
    #     자신의 처리없이 배열들을 자식으로 돌고, 그 반환값을 활용해 끝처리를 한다.
    for i in range(N):
        # [5] 이미 사용되어 상태비트에 마킹되어있다면, 건너띈다.
        # -> 처음엔 상태비트가 0000이라, 다 시도하게 된다.
        if used & 1 << i:
            continue
        # [6] 사용한 적이 없는 원소의 경우,
        #    (1) cnt+1해서 원소1개 사용했다고 알려주고,(2개 선택시 종료하고 반환)
        #    (2) used | 1<<i, i번째를 살려주고
        #    (3) 선택된 i번째 매핑값 lst[i]를 통해 중간계산결과를 계산해준다
        #     ->  val * 10 + lst[i]
        #     -> 먼저 뽑힌 수(2회제한이라 첫번째수, 첫번째수 계산시에는 val이 0이라 *10해도 0) x10 + 2번째 뽑힌 수
        #    업데이트 인자 작성이 어렵다면, 제일 처음에는 파라미터에 최초인자가 온다고 생각하자
        #    val * 10 + lst[i] -> [처음에는 val이 0만 오니까, 매핑원소만 val 자리에 들어갈 거야]
        # solve(cnt + 1, used | 1 << i, val * 10 + lst[i])
        # [7] 자식 재귀solve(cnt+1, )이 반환해줄 값val는, cnt == 2종착역에 걸려서 완성된 val이다.
        #     -> 종착역에서 완성되어 반환된 val을 지역변수에 모아두고, 가장 큰 것만 모우도록 max업데이트한다
        #     자식재귀에 넣어주는 업데이트 인자에서의 기존 파라미터는, [직전에 업데이트된 xxx]로 해석하자.
        ret = max(ret, solve(cnt + 1, used | 1 << i, val * 10 + numbers[i]))

    # [8] 반복결과 만들어진 ret(2개 선택후, 자식이반환해준 최종val(선택된 순서대로 자리수 합), 의 최대값)
    return ret



if __name__ == '__main__':
    # 완전탐색: 탐색N수 -> 실행시간O(n)으로 비례
    # -> 최적화나 다른알고리즘(이진탐색)을 이용한다.
    # (1) 순차탐색 -> for로 하나하나 다 돌면서 비교
    # -> 찾으면 index 못찾으면 -1을 반환
    def sequential_search(arr, x):
        for i in range(len(arr)):
            if arr[i] == x:
                return i
        return -1


    # print(sequential_search([1, 2, 3], 2))# 1
    # print(sequential_search([1, 2, 3], 0))# -1
    ## 최악의 경우 -> 마지막원소 or 없는 원소를 찾는 경우 다 돌아야한다

    # 이진탐색: 이미 정렬된 배열에서 절반씩 줄여가며 탐색
    # 찾는값 vs [정렬된 배열의 가운데값]을 비교해서, 절반을 날려서 처리한다
    # -> 탐색의 범위가 1회탐색마다 절반씩 줄어든다.
    # -> N걸릴 게 lgN만큼 걸린다.

    # (2) 2개이상의 원소에 대한 완전탐색을 하려면 경우의 수를 일단 나열해야한다.
    # 경우의수1: 순열 -> [선택 순서]가 결과에 영향을 미친다
    # 예) { 1,2, 3, 4} -> 만들 수 있는 가장 큰 두자리 수를 구하라
    # --> 1 2 선택시 vs 2 1 선택시 다른 case가 된다
    # --> 순열로 나열해야한다

    # 경우의수2: 조합 -> [선택 순서]가 결과에 영향을 미치지 않는다.
    # 에) {1, 2,3, 4} -> 두수를 더했을때 가장 큰 합을 구하라
    # --> 1+2나 2+1나 같은 case
    # --> 교환법칙이 성립하는 연산을 요구하는 경우, 조합으로 나열한다
    # --> 조합으로 나열한다

    ## my) 문제에 따라, 완전탐색 전 2개이상의 원소로 만드는 경우의 수를 순열로 나열할지 vs 조합으로 나열할지 결정한다
    # -> 교환법칙이 성립하는 연산(+, x)을 요구하는 경우, 조합으로 나열한다
    # -> 교환법칙성립x( +,x를 제외한 대부분)의 연산은, 순열로 나열해야한다

    ## 탐색 전 순열나열 예제
    # 1,2,3,4 중 가장 큰 두자리 수 찾기
    # -> 2개 선택하는 것이 교환법칙성립x( 12 != 21)
    # -> 순열로 case들을 나열해놔야한다
    # input
    # 4
    # 1 2 3 4
    N = int(input().strip())
    numbers = list(map(int, input().split()))
    # print(n, lst)

    # [1] case별 순열을 만들 때, 각 숫자별 상태값을 먼저 선언하는데
    #     여기서는, 상태값을 [0으로 시작하는 bit]로서, 변수선언 없이, 인자로 시작해 업데이트 한다

    # [2] 재귀를 통해 만들어나가는데, 전역변수에 마킹이 아니라,
    #     중간계산결과를 가지고 다니며 업데이트해서 결국 반환하게 한다.
    #     stack(depth) 횟수에 제한을 걸과 싶다면, 첫번재 파라미터로 N이나 0으로 시작해서 제한을 둔다.
    #     -> 여기서는 2개의 수가 선택되면 재귀종료후 중간계산결과를 반환해서 끝낸다.
    #     -> 순열이면서 두 수를 선택하면 끝이다.
    # solve(cnt, used(bit), val)
    print(solve(0, 0, 0))

    # [9] 재귀 천천히 해석과 그림
    # 그림설명: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812014029436.png
    # def solve(cnt, used, val):
    # -> (1) 재귀호출이 되서 올라가면, cnt가 올라가있고/ used가 마킹되어있고 /val에는 값이 첫번째원소 1이 더해진 상황이다.
    #     if cnt == 2:
    #         return val
    #
    #     ret = 0
    # -> (2) 그 상태에서 다시 for문을 돌게 된다.
    #     for i in range(n):
    # ->      (3) 이제는 1이 마킹되어서 자식호출시 패싱될 것이고 배열의 2,3,4만 돌게 될 것이다.
    #         if used & 1 << i:
    #             continue
    # ->      (4) 자식재귀가 반환한 값은 종착역에서 반환되는 [완성된 최종val]이다
    #             이것들을 재귀정의부의 반복문에서 최초자식들마다 다 모이게 된다.
    #              1-2, 1-3, 1-4 / 2-1, 2-3, 2-4 / ...
    #              최초재귀는 자신의 끝처리로서, 자식들의 여러개 반환한 값들을 집계해서 1개의 값만 반환해야하므로
    #              자식들이 반환하는 값들의 최대값을 뽑아낸다.
    #         ret = max(ret, solve(cnt + 1, used | 1 << i, val * 10 + lst[i]))
    #     return ret
    pass

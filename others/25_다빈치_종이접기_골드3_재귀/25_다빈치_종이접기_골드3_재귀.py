import sys

input = sys.stdin.readline
# sys.setrecursionlimit(20000)


# (3) 파라미터 규칙을 i -> 열(좌우), j -> 행(상하)
#  -> 상하 접을 경우, i(열)를 살리며 접는다고 해서 fi
#  -> 좌우 접을 경우, j(행)릏 살리며 접는다고 해서 fi
def solve(fi, fj, si, ei, sj, ej):
    # (4) 재귀로 접어주는데, 그 종착역은 접는 횟수가 상하==k and 좌우==k를 둘다 만족해야한다.
    if fi == k and fj == k:
        # (5) 다 접혔으면, 1점에서 모여스 si==ei, 열으 시작과 끝 / sj==ej 행의 시작과 끝좌표는 동일할 것이다
        # -> paper라는 전체좌표에서, 시작행, 시작열의 좌표의 한점 -> 문제에서 주어진 h를 좌표1점에 value로 집어넣는다.
        print(si, sj)
        paper[si][sj] = h
        return

    ## (7)  이제 시작시, 접는 순서(folds)가 2k개 들어있게 된다. 한변길이4  2**2-> 2*2번  2**3 -> 2*3번 접어야됨
    # -> 이, folds에서, 0부터 시작하는, 접힌횟수(fi + fj)를 인덱스로 주면 된다.
    #    합으로 주어지면, 둘 중에 1개가 증가하더라도, index로 반영되어 다음 요소를 가져오게 된다.
    #    최종적으로 2k개까지 된다.
    #    lst원소갯수 -> 0부터 시작하는, 원소부분갯수1 + 원소부분갯수2로 나누면, 어느것이 증가하더라도, 반영해서 다음 것을 뽑을 수 있다.
    #                 0부터 시작하고, [종착역이 원소갯수]면 -> 원소갯수-1까지 시행되어, 최총 원소갯소만큼 처리된다.
    current_fold = folds[(fi + fj) % 4]  # 접은 시행 횟수 0,1,2,3 -> lst 속 접는 방법과 매핑되어있다.
    # 가로 2번 접었고, 세로 1번 접은 상태라면.. 다음것으로  종착역으로 가면.. 2 + 2 -> 여기까진 올일 없다... -> 종착역에서 빽 됨.

    ## (8) 현재 접는 순서에 따라... 다음으로 node로 뻗어나간다.
    if current_fold == 'D':
        # 아래로 접히면, 행접fi를 +1해준다.
        # (9) 아래로 접어주었다면, 2**3 by 2**3 예시에서는,
        #     row좌표만 내려간다. 홀수일 때, //2 + 1은 가운데, 짝수일때는, 가운데에서 한칸 더 간(아래) 좌표이다.
        #    시작 행좌표가, 가운데에서 한칸 내려간쪽으로 간다.
        #     col좌표는 그대로이고, row도 끝좌표는 그대로이다.
        #    -> 아래쪽의 1/4된 정사각형을 담당한다.
        solve(fi + 1, fj, (si + ei) // 2 + 1, ei, sj, ej)
        # (14) 다음 재귀 호출이후 부분은, [종착역에서 올라오는 부분]인데,
        #      => 접는 [재귀가 종착역에서  백트래킹하는 부분에서 펴는 역 역산]을 할 수 있다.
        #      우측하단 사각형 1개를 생각해보면,
        #     <여기는 D로 접어놓은 것을 다시 펴는 순간>이다. 그게 언제인지는 stack결졍변수를 통해 파악해야한다.
        #     [1] 맨처음(종착역탈출한 총 횟수가 2k-1 번째연산)에는, 모두 접혔다가 펴질 땐, 마지막에서 위로 [+1개의 단위행렬이 늘어나고]
        #         2번째(횟수합 2k-2의 stack연산)일 때는, [위로 + 2개의 단위 행렬이 늘어나고]고.. 역순으로 2배씩 단위행렬이 늘어난다.
        #  => 반복문으로 늘어나는 행렬을 처리해보자.
        # for i in range()
        # => range에도 적어줄 수 있지만, 복잡해지므로, 따로 빼서 처리한 뒤, range에 넣어준다.
        # (16) 15에서, 1부터 2**k가 역순으로 나타나는 unfold_step을 range에 [d로 접은 횟수 fi]를 넣어준다.
        #    => 어차피 해당방향으로는 k번이 한계이므로, 방향별 접은 횟수인 fi, fj만 생각하면 된다..????!
        #   ex> fi==3 -> 종착역 직전부터 백트래킹
        #    -> 파라미터 fi==2 상태 -> ((((다음재귀는 업뎃fi인 fi==3을 갔다 빠져나옴)))) -> fi==2-> [4,2,1] [2] -> 반복문 1번 반복
        #    -> 파라미터 fi==1 상태 -> ((((다음재귀는 업뎃fi인 fi==2을 갔다 빠져나옴)))) -> fi==1-> [4,2,1] [1] -> 반복문 2번 반복
        #  => [단위행렬이 추가될 갯수만큼, [0부터 갯수-1까지] 반복문을 돌린다]는 의미가 된다.
        #   만약, + 1개 단위행렬 추가시, i는 0의 1번을...
        #        + 2개                i  01의 2번을
        #        + 4개                i  0123의 4번을 반복하면서
        #   추가된 단위행렬의 좌표를 [paper]에 찍으면 단위행렬 추가다.
        # => 추가되는 행렬의 시작 행좌표를 i가 담당하게 될 것이다.??
        #    0 1 -> si + 0
        #    2 3
        #    0 1 -> si + 2
        #    2 3
        for i in range(unfold_step[fi]):
            # (17) 역순으로 종착역(fi==3)을 빠져나온 순간 (fi==2)부터,  +1, +2 +4 씩 반복문을 도는 중
            #    => 마지막 1개의 단위행렬의(si,sj애 h로 찍음), 추가되는 단위행렬을
            # (17-1) 좌표를 이동시키기 위해, [상하접기]에서 변화없는 열좌표들을 처음부터 돌면서
            for j in range(sj, ej + 1):
                # (17-2) 현재는 해당재귀의 back부분으로서, 좌표들이 [접기 전si, ei, sj, ej]를 사용할 수 있는 상태다
                # row를 추가 단위행렬 갯수만큼 반복하되, i를 쓸 수 있다. i ->0 ,01  0123 으로 나아간다.
                # 이것을 통해. 추가될 단위행렬의 좌표를 paper에 찍을 수 있다
                # paper[si + i][j] = ??
                # (18) 추가적으로 대칭적인 행렬을 빈행렬에 찍는다면, [값참조할 대칭행렬좌표]를 넣어줘야한다.
                #      D로 접힌 경우, - 방향을 기준으로 데칼코마니처럼 참조해야한다.
                #     현재좌표가 si + i, j이므로... 참조해야할 좌표는
                #     ei - i, j를 참고해야한다?!   [  1 2 | 3 4 ] -> k만큼 갔따면 (전체len-1-간index)
                #     len(ei + 1) - (1) - (si(0) + i) =  ei - i
                #      si는 시작index이므로 0으로 보고, ei는 len-1로 보면..
                #         ei+1 -1 - i   =  ei - i만큼 간것이 대칭 좌표다.
                # paper[si + i][j] = paper[ei - i][j]
                # (19) 추가적으로, 대칭좌표의 값을 바로쓰는 것이 아니다.
                #      D일때, 펴질 때 매칭되는 값을 unfold_values 에 매핑해놨었다.
                #      => 매핑할 때, [기본행렬의 값만 있으면 -> 그 값이 펼칠때 어떤값으로 매핑될지]를 매핑해놨었으니
                #      대칭기본행렬의 값을 뽑은 상태인 paper[ei-i][j]에 다가 해당방법의 dict만 추출해주면된다.
                #      이 때, list의 index에 맞게 해당값을 순서대로 매핑해놨을 것이다?!
                # paper[si + i][j] = paper[ei - i][j]
                paper[si + i][j] = unfold_values[current_fold][paper[ei - i][j]]

    elif current_fold == 'U':
        # (9-1)
        # 위로 접었다면, 행끝좌표만 절반+1로 올라오게 된다.
        # -> 짝수라면 //2하면, 가운데보다 한칸 덜간 왼쪽(위쪽)이다.
        solve(fi + 1, fj, si, (si + ei) // 2, sj, ej)

        # (20)
        # for i in range(unfold_step[fi]):
        # => fi가 종착역 직전인 2일때부터 들어가서, 그땐, 0부터 +1까지 반복?
        # fi= 0 1 2가 진행된다, 그에 따라서 1부터 2^i가 역순으로 진행되어야하므로
        #    3-1-fi = 2 1 0  (index의 역순은 len-1- 반대index)
        #    => 0부터 시작하는 것의 역순은 index의 역순을 쓴다 len-1-index
        #    3-fi = 3 2 1 (0부터 시작하는 index에 대해 1부터 역순은 len-반대index)을 쓴다.
        #     2**(3-fi) = 8 4 2
        #     2**(2-fi) = 4 2 1(0부터 시작하는 index에 대해 제곱의 역순은 순수index의 역순)을 써야,, 1부터 시작한다.
        # for i in range(2 ** (k - fi)):
        for i in range(unfold_step[fi]):
            for j in range(sj, ej + 1):
                # 위로 접어줬으니, 밑으로 행렬이 늘어나는 형태가 된다.
                # si을 0으로 생각했을 때, 0부터 i만큼 간 좌표 -> 대칭좌표는? -> (ei+1)-1-i -> ei -i
                # paper[ei - i][j] = paper[si + i][j] # 참조좌표는 직전의 start좌표들을 이용한다
                paper[ei - i][j] = unfold_values[current_fold][paper[si + i][j]]



    elif current_fold == 'R':
        # (9-2)
        # 좌우로 접는다면, 행좌표는 변화가 없이, 열좌표만 시작-> 가운데에서 우측칸으로 기준이 바뀌기ㅔ 된다.
        # => 시작점이 바뀌도록 업데이트한다.
        solve(fi, fj + 1, si, ei, (sj + ej) // 2 + 1, ej)

        # (21) 좌우로 접었을 대는, 행은 고정이고, 열이 정해준 step에 따르게 된다.
        for i in range(si, ei + 1):
            for j in range(unfold_step[fj]):  # fi -> fj
                # 행은 그대로 있고, 대칭만 j로 바뀐다.
                # 기준은 오른족에 있고, 찍을 좌표는 왼족에서 만들어서 참조해서 찍어야한다.
                # 0부터 sj에서 + j만큼 움직였다면, 대칭은.. len-1-움직인index = (ej+1)-1-움직인index = ej -index
                # paper[i][sj + j] = paper[i][ej - j]
                paper[i][sj + j] = unfold_values[current_fold][paper[i][ej - j]]

    else:
        solve(fi, fj + 1, si, ei, sj, (sj + ej) // 2)
        # (22)
        for i in range(si, ei + 1):
            for j in range(unfold_step[fj]):
                # paper[i][ej - j] = paper[i][sj + j]
                paper[i][ej - j] = unfold_values[current_fold][paper[i][sj + j]]

    ## (10) node를 진행할 수록, [기준 사각형]의 크기가 줄어뜸에 따라 좌표 시작점들을 이동해주는 작업을 했다.
    ##      이렇게 각 방법으로 접을때마다 case마다 1개의 재귀만 호출되면서 [사각형 크기와 좌표]가 바뀔 것이고
    ##      2k번 다 접히면, 1번에 1개의 재귀만 호출되니, 꼬리재귀처럼, [1개의 사각형]이 된다.
    ##      => case마다 얻어진 [접힌 사각형 1개]의 좌표를 [NbyN 마킹용  paper배열]에 h값으로 기록해놨따
    ##      => 기록해놓은 paper를 통해, 역순으로 펴주면... 원하던 그림이 된다?!


if __name__ == '__main__':
    # 종이접기: https://www.acmicpc.net/problem/20187
    k = int(input().strip())
    folds = input().split()  # 문자열 input은 list(map(int, )))안해도 된다. 바로 split만 하면 list
    h = int(input().strip())
    ## 4각형 문제 -> 분할 정복으로 해결할 것이다.(재귀 점화식)
    ## 접는 방법에 따라, 종착역 기준좌표가 달라진다. -> 0 1 2 3 어디좌표에서 만날지 모른다.
    ## -> 이럴 경우, 직접 마지막 좌표를 찾자. 접는 것으로 인한 -> 좌표변환 -> 한 점에서 모일 것이다.

    # (13) 연산별, 펴줄 때, 각 단위행렬당 매핑될 딕셔너리
    # 0 1
    # 2 3
    # -> U를 폈을 때 매핑되는 값
    # 2 3
    # 0 1 -> D와 동일하지만 매핑
    # -> R를 폈을 때
    # 1 0
    # 3 2
    # -> L를 폈을 때
    # 1 0
    # 3 2
    unfold_values = {
        'D': [2, 3, 0, 1],  # 기존 0 1 2 3 2by2를 매핑한 값
        'U': [2, 3, 0, 1],
        'R': [1, 0, 3, 2],
        'L': [1, 0, 3, 2],
    }

    # (15) 종착역에서 나와, 역순으로 올라가면서, 펴지면서 추가되는 단위행렬 갯수가 + 1,  + 2, + 4 개씩 늘어남을
    #      역순은 range로 뒤집고
    #      1 2 4 8 ... 2**k를 표현하기 위해
    #      정순을 생각한 뒤, [ (2**i) for i in range(0, k+1)]
    #      range의 앞뒤를 바꾸되, 뒤쪽은 +1이 아닌 -1, 앞쪽은 해당 수부터.. 내려가게 줘야한다.
    # => k번 접는다고 치면, k==3일 때,
    #    3번재 접을 때 -> +1
    #    2번재  접을 때 -> +2 ,
    #    1번째 접을 때 -> + 4개가 찍혀야한다.  1,2,4 를 역순으로 배치하려면, [식인 2**i는 그대로두고 range를 거꾸로] 돌린다.
    unfold_step = [(2 ** i) for i in range(k, 0 - 1, -1)]
    # print(unfold_step) # [4, 2, 1]

    # (1)  재귀로 시작한다. 구멍뚫은 위치는 주어졌으니 -> 다접으면 한 잠 -> 접은 것을 펴주면서, 점들을 찍을 것이다.
    #   -> node탐색말고도, 도형 문제의 펴는 문제도, node탐색으로 간다.
    #   stack결정변수는 펴는 횟수 == 접는 횟수 == k일텐데, [한변이 2**k이니, 상하 / 좌우 따로 k번씩 움직인다].
    #   -> 인자를 상하펴는횟수(종착k), 좌우펴는횟수(종착k)를 따로줘야한다.
    #   node탐색이 동시에 3개씩 일어나면서 시작이다(0번쨰는, 자신의 처리없이, node를 뻗기만 한다)
    # solve(0, 0)
    # (2) 이제 매 node마다 좌표가 업데이트되니, [좌표업뎃은, 열의 시작, 끝, 행의 시작, 끝 index]로 업데이트 해나간다.
    # -> 2**K는 상수로 만든다.
    n = 2 ** k

    # (6) 좌표역할을 해줄 paper를 만든다. 0초기화하고, 접힌 좌표 1개만 h값이 들어가 있을 것이다.
    # -> 좌표는 N by N (한변의 길이len 2**k -> N -> 0부터 N-1까지를 좌표로 잡는다)
    paper = [[0 for _ in range(n)] for _ in range(n)]

    solve(0, 0, 0, n - 1, 0, n - 1)

    # (11) 위에 재귀는 순수, case마다 [주어진 방식대로 좌표이동하며 계속 연산]하기 위해
    #      4가지 접는 방식 중 [택1 연산의 지속 업데이트]하기 위해 [재귀를 활용]했고,
    #      그 연산이 끝나는 곳을 종착역 삼아 -> 좌표이동이 다 끝나면 [2by2]으로 모이는데,
    #      구멍뚫리는 위치(h)를 2 2 행렬에 현재 넣지말고, 값으로만 넣어놓고, 나중에 처리할 수 있게 된다??
    #     => 이제  2by2를 1점이라 생각하고 역순으로 펴나간다. 그 이후 나중에 h를 확인해서 2by2 중 1개 좌표를 선택하면 된다.

    # (12)  [택1 연산]이 접을 때는, 쉽게 이해가 된다. 좌표 1개만 업데이트해주면 됬었다.
    #     하지만 [택1 연산]으로 2by2행렬을 펴주는 것은 생각하기 쉽지 않으니, 먼저 생각하고 들어간다.
    # 0 1
    # 2 3
    # -> D를 펴주면, 위로 펴진다.
    # 2 3
    # 0 1
    # 0 1
    # 2 3
    # => 이 변환과정을, 2by2를 1개 단위로 인식하고, 거기의 value들 또한 1개의 list에 묶음으로 기억해놓자
    # => 재귀를 돌아오면서, 펴지는 행렬의 좌표를 먼저 따놓고, 그만큼 value들을 입혀주면 된다.
    # => [택1 연산]에 재귀호출후, [해당 재귀 밑에서 호출하는 과정] == [역 연산의 D를 펴주는 과정]이며
    #    거기서 [펴지는 행렬 처리]를 할 거인데, [매 2by2의 단위행렬]마다 넣어줄 값을 매핑한다
    # => 연산별 value매핑은 dict안에 list의 전역변수로 선언해서 관리한다.

    # (23) solve문이 다 돌고 나면, paper에는 구멍이 뚫려있을 것이다.
    for row in paper:
        print(*row)

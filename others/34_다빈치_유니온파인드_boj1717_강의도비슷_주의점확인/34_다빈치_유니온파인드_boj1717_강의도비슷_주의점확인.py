import sys

input = sys.stdin.readline
# (8) 재귀의 재한을 10만 정도로 풀어준다
sys.setrecursionlimit(100_000)

#(5)
def find(a):
    # 자기자신이 대표가 된 것을 찾아 거슬러 올라간다.
    if a == p[a]:
        return a
    # 못찾았으면, 재귀로 자신->부모로 업뎃후 부모의 부모를 계속 찾아올라간다
    # -> 반환받은 대표값은, a의 대표값으로 업뎃한다.
    # -> a의 대표값(root)값 = 종착역에서 찾은 값으로 업데이트 해주고 반환한다
    p[a] = find(p[a])
    return p[a]


def union(a, b):
    # (4) 합치지기 전에, p배열을 이용해서, 각 원소의 대표(root)를 찾아야한다
    # -> find함수를 만들어 서야한다.
    pa = find(a)
    pb = find(b)
    # (6) 문제 요구사항에 따라 union시 어느 대표값을, 둘중의 대표값으로 할 것인지 정해야한다
    # -> 여기서는 대소비교도 안하고 그냥, 오른쪽 원소의 대표값을 -> 공통 집합의 대표로 정하고
    # -> a의 대표값 원소의 대표값을 pb로 바꿔준다.
    # => a의 대표값의 대표값을. b의대표값으로 바꿔주어. 공통집합의 대표값은 pb이다.
    p[pa] = pb


# (2) 각 요소들의 대표값들을 알아야한다. 그 값들은 자기자신을 초기값으로 가진다고 했다.
# -> 전역 변수로 만든다.


if __name__ == '__main__':
    # 유니온파인드: 백준1717번: boj.kr/1717
    # -> 크루스칼 알고리즘에도 사용된다.
    # 분리집합 {disjoint set}
    # ex> 새학기에 누구랑 같은 반이 되었는지 알고 싶어한다. -> node가 속한 집합을 알고 싶을 때
    #     철수,영희 같은반 /   둘리,또치 같은반이라고한다.
    #     이 때, 철수, 둘리가 같은반이라면 -> 4명 모두 같은반이다.
    # 집합의 구성요소들을 빠르게 합치고union /
    # 속한 소속이 같은지 빠르게 찾는다find

    # 1. 각 요소들을 같은 집합으로 합치자.
    # -> 처음에는 각자가 자신의 집합 대표(root)
    # -> Union(a, b)를 통해 b의 대표(root)를 a로 명시함

    # 2. 각 집합의 대표(root)가 나올때까지 계속 찾는다.
    # -> 각 집합의 대표는, 초기화(자기자신)이후 한번도 안바뀐 요소가 그 집합의 대표가 된다.
    N, M = map(int, input().split())

    # (3) 각 원소의 대표를 확인할 수 있는 lst를 만든다.
    p = [i for i in range(N + 1)]  # 0부터 n까지 자기자신의 index를 값으로 초기화한다

    for _ in range(M):
        q, a, b = map(int, input().split())

        if q == 0:
            # (1) union을 메서드로 수행한다.
            union(a, b)
        else:
            # (7) find
            if find(a) == find(b):
                print("YES")
            else:
                print("NO")
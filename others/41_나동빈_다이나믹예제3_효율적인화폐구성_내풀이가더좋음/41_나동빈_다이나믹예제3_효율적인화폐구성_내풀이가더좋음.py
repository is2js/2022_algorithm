import sys

input = sys.stdin.readline

if __name__ == '__main__':
    # ## 효율적인 화폐 구성
    # # 갯수 최소로 사용하여 합이M원이 되도록 & 몇개든 사용 가능
    # # ex> 2, 3 단위화폐 -> 15원 -> 3x5
    # N, M = map(int, input().split())
    # money_unit = []
    # for _ in range(N):
    #     money_unit.append(int(input().strip()))
    #
    # money_unit.sort()

    # ########################## 내 풀이
    # ## my) 합의 점화식은, 빼서 부분문제를 만든다.
    # # 15 = 화폐단위 택1 +  (15-택1 수)
    # # f(n) = k + f(n-k) -> k가 어느것을 선택하면 더 적은 값일지 모르니, 반복문을 통해 돌아야한다.
    # d = [-1] * (10000 + 1) # d[0]일 경우 더이상 계산카운팅에 안들어가도록 0을 반환해야하므로, 화폐단위에 없는 것들은 -1로 대체
    # d[0] = 0 #
    # for money in money_unit:
    #     d[money] = 1
    #
    # for i in range(money_unit[0], M + 1):
    #     min_count = float('inf') # 나중에 dp초기값을 큰수로 초기화해놓고(inf or 요구사항보다 큰값) -> 가변변수 없이 d[i]로 업데이트해주면 더 좋다
    #     for money in money_unit:
    #         if money > i: # 화폐단위가 현재구성할 값보다 크면, 그 이후로는 안돌아도 된다.
    #             break
    #         if d[i-money] == -1: continue # 기존에 저장한 값이 없는 곳이면 건너띈다.
    #         min_count = min(min_count, 1 + d[i-money])
    #     d[i] = min_count
    #
    # print(d[15])

    ## 풀이
    # ai -> 금액i를 만들 수 있는 최소한의 화폐 갯수(작은 문제부터 차례대로 점화식 설계)
    # k = 각 화폐의 단위
    # 점화식 = 화폐단위 k를 하나씩 확인하며(2중포문)
    # -> ai-k를 만드는 방법이 존재하는 경우, ai = min(ai, ai-k +1)
    # -> ai-k를 만드는 방법이 존재하지 않는 경우, ai = INF

    # a0 -> 0원을 만드는 것은, i-k금액의 마지막 종착역으로서 0을 넣어줘서 추가 카운팅 없이 종료되도록 해야한다
    # 만들어질 수 없는 값은 INF로 초기화해둔다. -> 현재 문제에서는 M이 10000까지 가능하기 때문에 -> INF대신 10001을 도달할 수 없는 값으로 사용할 수 있다.

    # 점화식을 세우기 전에 확인할 때, 화폐단위 2,3,5를 1개씩 dp table을 작성해주면 된다.
    # k==2 인경우,
    # 0   1   2   3     4    5     6   7
    # 0 10001 1 10001   2  10001   3  10001   -> 화폐단위가 2라서, 5가 안되면 7도 안된다. / 1(x) -> 3(x)
    # -> 반대로 2가 가능하면 -> 화폐단위 2만큼 움직인 4도 최적의 갯수로 구해질 수 있다.
    # k== 3이 추가된 경우
    # 0   1   2   3     4    5     6        7
    # 0 10001 1   1     2    2     3  2(5)+1 or 2(4)+1   -> 화폐단위가 2, 3이라서, 기본화폐 +2나 기본화폐+3의 위치도 +1방법으로 가능해진다.
    # k== 5가 추가된 경우
    # 0   1   2   3     4      5     6        7
    # 0 10001 1   1     2    2=>1    3  2(5)+1 or 2(4)+1 or 1(2)+1로  2에서 5칸 넘어서 만들면 더 최소갯수다

    n, m = map(int, input().split())
    # n개의 화폐단위를 입력받아 모아두기
    money_unit = [int(input().strip()) for _ in range(n)]

    # 점화식 a(n) = k + a(n-k) k는 화폐단위에서 택1 -> 최적의해를 저장해줄 dp table
    # -> 0초기화만 할게 아니라, 도달 불가능한 값은 inf or 문제제시 최대값(10000)보다 +1해준 값으로 처리해준다.
    d = [10000 + 1] * (m + 1)
    # 초기항(재귀로치면 종착역)을 반드시 명시해줘야한다.
    # -> 점화식(재귀)가 n-k의 형태로 이루어져있으며, 0원을 inf도 두면 안된고 종착역의로 0원을 만드는 최적의 해를 0으로 준다.
    # -> 그외 화폐단위에 1을 주지 않아도 된다.  1 + d[n-k]에 의해 0원이 종착역으로 있으면, 알아서 1로 채워진다.
    d[0] = 0

    # 나는 d[i]를 만들 때마다, 모든 화폐단위들을 탐색해서 업뎃했지만
    # 강의에서는 모든화폐단위를 탐색하면서, dp table을 먼저 채워나갔다.
    # -> 각 i번재에 대해 모든 경우의 수를 비교해보는 것이 아니라,
    # -> 화폐단위를 돌면서, 매번 dp table을 최소값으로 업데이트한다. -> 나한테는 안맞는 방법인 듯
    for i in range(n):
        # 현재 화폐단위를 시작으로 m까지 dp테이블 채우기
        for j in range(money_unit[i], m + 1):
            # 기존 저장된 테이블값이 없으면 아예 진행 못하기
            if d[j - money_unit[i]] == 10001: continue
            # 현재 저장된 값(default INF 10001)과 비교해서 더 작은 값으로 교체하기
            d[j] = min(d[j], 1 + d[j - money_unit[i]])

    if d[m] == 10001:
        print(-1)
    else:
        print(d[m])



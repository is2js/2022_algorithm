import sys

input = sys.stdin.readline


def solve(cnt, pos, val):
    # [1] stack결정변수는 2개가 선택되면 종료한다
    if cnt == 2:
        return val
    # [6] 조합은 선택안하는 경우가 있기 때문에 cnt가 안올라가기도 한다
    #   -> 무조건 변하는 변수 pos로 종착역을 추가해준다.
    if pos == N:
        return -1 # 반환될 최종값들은 max를 타는데, 거기서 제외될 값을 넣어줘야한다.
    #                None을 반환하면 root에서 집계시 에러가 날 것이다.

    # [2] 자신의 처리로서, 자식재귀 호출()후 값을 받아 집계한다
    # (1) 다음스택에서는, (현재수의 수를 선택했기 때문애)다음위치를 사용하는데, 결과값으로는 (선택된)현재위치의 값을 선택하여 -> 누적합해준다.
    # -> 선택했다 == 자식재귀에, [현재위치 값numbers[pos]]가 자식재귀 [결과값 업데이트]에 사용된다
    # solve(cnt + 1, pos + 1, val + numbers[pos])

    # [3] 조합에서는, 선택안하는 경우도 재귀를 태운다.
    # -> 선택안했다 == 자식재귀에, numbers[pos]를 사용한 결과값 업데이트가 없다
    #    1) cnt를 올리지 않고, (cnt)
    #    2) 위치만 + 1로 다음으로 넘어간다 (pos+1) -> 선택유무와 상관없이 다음위치로 간다.
    #    3) 선택한 수가 없기 때문에, val의 업데이트 또한 없다.
    # solve(cnt, pos + 1 , val)

    # [4] 현level에서 선택한 경우의 최종return값과, 선택안한경우의 최종return값을
    #     max로 비교해서 추출하여 1개로 집계하여 반환한다
    # -> 집계는 묶어놓고 처리한다.
    selected = solve(cnt + 1, pos + 1, val + numbers[pos])
    unselected = solve(cnt, pos + 1 , val)
    ret = max(selected, unselected)

    # [5] 선택 안하는 경우,cnt가 안올라간다 -> stack결정변수가 안올라가는 경우가 발견되면
    #   -> 다른 것으로 막아야한다.
    #   -> 계속 선택안하는 경우에 빠질 땐, 다른변수로 처리해야한다
    #   -> pos는 계속 증가하므로, pos의 마지막 탐색범위인 len -1을 넘어서는 경우
    #      종료시키는 종착역을 추가한다.

    return ret

    pass


if __name__ == '__main__':
    # 경우의수 예제2 -> 조합
    # -> 교환법칙이 성립하는 연산에서 2요소 선택하기

    ## 가장 큰, 두수의 합, 구하기
    # -> 두수의 합은 교환법칙이 성립하기 때문에, 순서가 결과에 영향을 안주므로
    # -> 순서와 상관없이 뽑으면 된다.
    N = 4
    numbers = [1, 2, 3, 4]

    # [1] 순열과 파라미터의 의미가 다르다
    #  (1) 순열 : solve( 제한될 cnt, 상태비트used, 중간결과값val)
    # -> 뽑는 순서가 중요하므로, [상태비트를 통해 depth별 사용된 순서대로 체킹]하여 재등장을 막는다.
    # -> level마다 먼저 체킹된 것은 뒤에 나올 수 없다.

    #  (2) 조합 : solve( cnt, pos, val ):
    # -> 뽑는 순서가 중요하지 않을 땐, [주어진 배열 순서대로 고정되었다 생각]하고
    # -> index를 포지션으로 사용하면서, 1개씩 늘려나간다
    # -> 선택할 수도 /안할 수도 있기 때문에, pos가 업데이트없이 자식재귀를 부를 수도 있다.
    print(solve(0, 0, 0)) # 7

    # [7] 그림과 설명
    # https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812024305922.png
    # root에서는 pos=0인 1에 대해
    # 선택O : 1
    # 선택X : -

    # 각 경우마다 pos +1 된 2를 선택하든지 / 선택안하든지 한다
    # -> depth마다 해당숫자를 선택하든안하든 pos는 무조건 증가한다. -> depth별 무조건 선택대상 값은 바뀐다.
    # 선택O : 1 2 -> 2개 선택되었다면, val은 누적합으로 업데이트 되니, 3이 반환
    #        1 -
    # 선택X : - 2
    #        - -

    # 다음depth는 3에 대해 선택할지 안할지 고른다
    # 선택O : 1 2 끝
    #        1 2 -
    #        1 - 3 -> 4반환 후 끝
    #        1 - -

    # 선택X : - 2 3 -> 5반환 후 끝
    #        - 2 -
    #        - - 3
    #        - - -

    # 집계는 매depth마다 해서 올라온다.
    # 자식도, 자식의 자식이 반환하는 2개의 return값 에 대해 max쳐서 올린다.

    # [8] 조합대신, 순열(상태비트 사용하여, 체킹된 tree에서는 재등장금지 -> 1->2/ 2->1 다른 tree에너 나옴)
    #  순열로도 답은 구할 수 있다.
    #  하지만, 조합(선택여부를 cnt와 val업데이트 반영하여 재귀호출 / pos는 무조건증가하여, 순서가 지나가면 재등장안함)
    #  조합이 경우의 수가 더 적기 때문에, 순열로 풀 경우, 제한시간이 초과할 수 있다.

    pass

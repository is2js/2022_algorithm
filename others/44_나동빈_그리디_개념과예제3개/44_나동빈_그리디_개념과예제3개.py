import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## greedy: 지금 당장 좋은 것만 고르는 방법
    # -> 정당성 분석 : 가장 좋아보이는 것을 반복적 선택해도, 최적의 해를 구할 수 있는 검토 해야한다.

    ## 예시: root node부터 거쳐가는 노드의 합을 최대로 만들고 싶다
    #          5
    #        /   \
    #       7      10     => greedy로 지금 당장 좋은 것만 고른다면 10이 선택된다.
    #     / | \    | \
    #    7  5  9   4   3
    #         (O) (X)     => 지금 당장이 아니라, 다 모으고나서 합으로 선택해야한다.

    # my) 합 -> 지금 당장 큰 것만 선택해야하는 문제가 아님. 다 모여야 의미 있다.

    ## 일반적인 상황에서는, greedy는 최적의 해를 보장할 수 없을 때가 많다

    ## 예시2: 거스름돈 문제 -> greedy 알고리즘 대표 설명 문제
    ## 동전이 무한개의 500, 100, 50, 10원짜리가 있는데, N원을 거슬러 줄때 최소 동전 갯수는?
    # (단, N은 10의 배수)
    # N: 1,260원
    # => 최적의 해: 가장 큰(greedy) 화폐단위부터 거슬러 주기
    # -> 500원 거슬러 줄 수 있는 만큼 다 거슬러주기
    # 500x2 , 100x2, 50x1, 10x1 -> 최적의해 6개..

    ## WHy?? 정당성은 어떻게 확보할까? ex> FourSquares 문제에서도.. 원래수보다 작거나 같은 가장 큰 제곱수를 빼주는 것이 최적의해가 아니었다.
    ## => 큰 단위가 항상 (모든) 작은단위의 배수여서, 작은단위 동전 조합으로 다른해가 나올 수 없는 상황이기 때문이다.
    ## ex> 800원을 거슬러줄 때, 500원,400원,100원이 있다면
    #   -> greedy : 500x1 100x3 -> 4개
    #   -> 500의 약수가 아닌 400원을 쓰는 경우, : 400x2 -> 2개 => 더 적은 갯수를 가진다.
    #   -> greedy한 값이, 나머지 값들의 조합으로 나올 수 없을 때는 정당성이 확보안된다.
    n = 1_260
    unit = [500, 100, 50, 10]
    # n % 500을 푸나... n % 100을 5번하나,  n%50을 10번하나,  n%10을 50번하나.. 같은 해가 나오므로
    # -> 부분문제가 겹치게 된다면, 큰 수로 처리하는게 더 좋다.
    # -> 원래문제의 나눈 나머지의 문제면.. 약수들로는 횟수만 늘어나고 결과는 같아진다...

    count = 0
    for coin in unit:
        count += n // coin
        n = n % coin

    print(count)

    ## 거스럼돈 시간복잡도 O(K) 화폐의 종류만큼
    # -> 금액과 무관하게 동전의 갯수만큼만 시간복잡도가 올라간다.

    ## 예시3: 1이 될때까지 -> 1로 빼거나 k로 나누거나 2가지 (k 2이상)
    #  시행횟수 최소값은??
    # 부분문제가 n-1 vs n//k  if n % k == 0
    # => 할 수 있다면 k로 나누는 것이 (greedy)가 최적의 해인가??
    # => k가 2이상이라면.. 무조건 나누는 것이 n을 1로 줄이는 방법 중 최적의 해이다...?!
    # => 다른 나누는 수가 붙으면 달라질 수도 있지만 (그 땐, dp를 통해 각 경우마다 만들어야한다)
    # => 1을 빼는 것보다 2이상으로 나누는 것이 ex> 2 -> 1  2 - 1 => 1번으로 동일, 그외에는 k로 나누는 것이 압도적으로 빨리 줄인다.

    # n, k = map(int, input().split())

    # count = 0
    # while n > 1:
    #     if n % k == 0:
    #         n /= k
    #     else:
    #         n -= 1
    #     count += 1
    # print(count)

    ## 스킬 이용: k로 나누어떨어지지 않다면, k로 나누어떨어지는 가장 가까운 값
    # -> (n // k) * k -> target
    # -> target이 될때까지 1을 계속 빼 나갈 수 있다.
    # -> 1을 빼는 횟수를 현재 n  - target (n=5, k=2 -> target=4, 5에서 4까지 1을 빼어줘야하는 횟수 5-4 = 1번)
    # -> 그만큼 counting 미리 해버리면 된다(반복문 안돌고) + n 을 target으로 업데이트
    # -> 이제 n은 k의 배수이지만, n=1, k=2 -> target = 0의 구간에 있을 땐.. 즉,
    #    나누는 값k == 구간의 길이  k보다 작을 땐, 나머지이므로, 0이 아닌 1까지 가는 것이므로 n-1로 횟수 카운팅
    # -> 그게 아니라면(n>=k) count + 1  n = n//k 으로 업데이트한다.
    ## => 나누어떨어질때까지 한번에 계산하면, 반복문횟수 == 1빼는횟수제외 k로 나누는 횟수만 시행하면 되므로
    #  => 시간복잡도가 크게 절약된다.(최대 1만빼서 O(N) -> 테크닉 O(lgN)으로 줄어든다.

    n, k = map(int, input().split())

    count = 0
    while n >= k:
    # while True:
        # (1) n이 k에 나누어떨어진다는 보장이 없으므로 확인 (나누어떨어지면 target이 n이 동일해짐)
        # -> n이 k로 나누어떨어지는 수target이 될때까지의 횟수를 계산하여 counting한다.
        # -> 만약 n이 k보다 작아도, target = 0이 되고, count는.. n-1이 아닌.. n이 된다?
        # -> n = target업뎃으로 인해, n은 0이 되고, count = n이 된다?
        # -> 그래도 맨 마지막에  count += (n- 1)로 인해, 1이 복구되어 제값을 찾아간다.
        # => 차라리 애초에 도는 것을 while n>=k로 해주는게 더 좋을 듯하다.
        target = (n // k) * k
        count += n - target  # target까지 1을 빼주는 횟수
        # (2) 카운팅 했으면 n을 target으로 맞춘다.
        n = target
        # (3) n이 나누는 수 == 구간길이인 k보다 작아지는 경우, 나머지들만 남아있다.
        # -> 나가서 1빼는 것으롬 처리해줘야한다.
        # if n < k:
        #     break
        # (4) k의 배수가 된 상황이므로 나누어준다.
        n //= k
        count += 1

    # (5) k보다 작아서 탈출한 순간이다.  그때의 n ~ 1까지 1을 빼주는 횟수 n-1을 카운팅한다
    count += (n - 1)
    print(count)
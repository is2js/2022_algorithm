import sys

input = sys.stdin.readline


def print_subsets(arr, n):
    # 3) 이제 부분집합을 이진수로 생각할 것이며, 부분집합의 갯수만큼 일단 반복문을 시행한다.
    #    이진수를 2**n개 => 이진수로는 1 << n 개 만큼
    #    반복문을 만들어서 돌린다.
    # -> i가 0부터 15까지 증가한다.
    # -> i를 1<<n비트로 돌아간다면,
    # -> i는 0000 0001 ~ 1111까지 증가한다.
    # -> i를 이진수로 생각해야한다.
    # for i in range(1 << n):
    #     print('{', end=' ')
    #     print(i, end=' ')
    #     print('}')
    # { 0 } -> 출력은 10진수로 나오지만 0000
    # { 1 } -> 0001 로 i를 생각해야한다.
    # my) 1 << n 쉬프트로 만들어 도는 것은
    #    원소 포함여부를 0 or 1로 이미 표시해놓은 것을 도는 것이다.
    #    i -> 이진수로 표현된 0000 ~ 1111까지
    for i in range(1 << n):
        print('{', end=' ')
        # 5) i는 원소포함여부 이진수이고
        #   이제는 원소배열을 돌아서, i에 arr[j]가 포함되어있는지
        #   확인한다.
        # 6) 이진수 & 1<<j 를 통해
        #    배열의인덱스j만큼 1을 << left shift하면,
        #    j번째자리에만 1로 불켜진 이진수를 만든다.
        #    이것을 원소포염여부 이진수와 &연산시키면
        #    해당 자리에 1로 불켜져 있는지 알 수 있다.
        #    ->1<<의 특징으로서 해당자리만 1로 만들고, 나머지자리는 0이 된다.
        #    -> &의 특징으로서 대상이진수1 나도 1일이 때만, 1로 들어온다
        #    --> & 1<<의 특징은, shift한 자리만 1, 나머지0 상태와 &연산하므로
        #        나머지자리는 다 0, shift한 자리는 1이면 1, 0이면 0이 된다.
        #    -> if문에 걸면, 1000 0100 0010 0001은 true, 0000이면 false다

        #    i==1010 차례 -> A0 B1 C0 D1 상태이다.
        #    -> 1<<0과 &를 하면  0000 -> A포함X
        #    -> 1<<1과 &를 하면  0010 -> B포함O
        #    -> 1<<2와 &를 하면  0000 -> C포함X
        #    -> 1<<3와 &를 하면  1000 -> D포함O
        #    -> 1<<j(배열인덱스)와 &를 하면 0j00번째가 0000 or 0100 으로
        for j in range(n):
            if i & (1<<j):
                # j자리에 불들어온 상태 (나머지자리는 모름)
                # -> 나머지도 돌면서 " "로 연결된다.
                print(arr[j], end=" ")
            # else:
            #     print("X", end=" ")
        print('}')


    # 7) 이진수 & 1<<j 는, 현재 이진수의 j번째자리가 불켜졌는지 확인후
    #    불켜졌다면, 그 이진수j번째와 매칭되는 배열속 j번째 수를 챙긴다.

    # 8) 정리
    # i번째 원소 포함여부 확인 ->  (비트로 표현된 집합) & (1<<i) -> 결과가 0이 아니면 1000 , 0100 -> 해당 원소가 존재함
    # -> my) 0100 이든 1000이든, 0000이 아닌 True/False만 판단한다

    # 9) i번째 원소 1만들어 추가(new)한 (비트표현 이진수 집합) 만들기
    #  -> (비트로 표현된 집합) | (1<<i)
    #   0101 -> 1번째 원소가 불안켜져있음
    #   0101 | (1<<1) = 0101 | 0010 = 0111
    # -> |(OR)의 특징상 원래 1이라면, 무조건 남아있고, 0이라도 1이 들어오면 살아난다.
    # -> 살리고 싶은 자리는 1을 만들어서, 0이었으면 OR 1로 1이 된다.
    #   [ | 1은 자신의 수를 살리는 성질이 있다]
    #   [ | 0은 자신의 수를 유지하는 성질이 있다]

    # 10) i번째 원소 0으로 만들어 삭제(new)한 (비트표현 이진수 집합) 만들기
    # -> (비트로 표현된 집합) & ~(1<<i)
    #   0101 -> 2번째 원소가 불켜져있음(포함됨)
    #   0101 & ~(1<<2) = 0101 & ~(0100) = 0101 & 1011 = 0001
    # -> &의 특성상 해당자리 0을 만들어주면 &후 불이 꺼진다
    # -> 원하는 자리를 0으로 만들기 위해 1<<로 이동한다면 not으로 뒤엎자
    #    원하는 자리는 0이 되고, 나머지자리는 0->1로 되어있다.
    #    [ & 1은 자신의 수를 유지하는 성질]이 있다.
    #    [ & 0은 자신의 수를 날리는 성질]이 있다.
    #    살아있떤 것은 그대로 살아있고, 원하는 자리는 & 0으로 인해 0이 되어 날아간다

    # 11) 비트연산자 성질 정리
    #   [ & 1은 자신의 수를 유지하는 성질]이 있다.
    #   [ | 0은 자신의 수를 유지하는 성질]이 있다
    #   => & 1이나 | 0은 유지하는 성질이 있다. 원하는 자리 나머지 타겟팅이다.

    #   [ & 0은 자신의 수를 죽이는 성질]이 있다.
    #   -> <<해당자리 원소를 불끄고 싶을 때>> 사용한다
    #   -> &이므로 &시 나머지는 유지되도록 &1이 되도록 만들면
    #   ->  1011 -> 0은 shift로 바로 못만드니 & ~(shift)로 만든다.

    #   -> <<확인을 위해 나머지 수들을 죽일>>일 때 사용한다
    #   -> 자신의 자리빼고 다 0으로 만들어서 &를 날리면 된다.
    #   -> &시 자신의 자리는 유지되어야하므로 1을 만든다.
    #   -> 0100 -> & (shift)로 만들어서, 자신의 자리빼고 다 죽인다.


    #   [ | 1은 자신의 수를 살리는 성질]이 있다
    #   -> 해당자리 원소를 포함하고 싶을 때 사용한다.
    #   -> |이므로 나머지는 유지되도록 0이 되도록 만들면
    #   -> 0100 -> | shift로 만든다.
    pass




if __name__ == '__main__':
    ## 비트를 이용한 부분집합
    # 원소가 n개인 집합
    # -> 부분집합의 갯수 -> 공집합포함 2**n개
    # https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811181516358.png

    # (1) 원소 n개 부분집합 -> 이진수 n자리로 매칭시켜 생각한다
    # ABCD 0000

    # (2) 0이면 해당원소가 없는 것, 1이면 있는 것
    #  { }
    #   0000
    #  {A, B, C, D}
    #   1111

    # 이진수는 <- 방향으로 0,1,2,3 인덱스
    # 0001 -> A

    # [1] 부분집합의 갯수
    # -> 2**n개 == 1을 << n번 left shift한 것과 같다 == 1 * 2**n
    # 0001   1 << n ->   10000 == 16

    # [2] 이진수 0000에서 +1비트씩 해주면 1111도달할때까지 불이 켜졌다 꺼졌다 하면서 16개 부분집합을 다 나타낸다

    ############## 코드로 짜보기
    # 1) 부분집합을 만들 lst를 가지고 있다고 가정한다.
    data = ['A', 'B', 'C', 'D']
    # 2) 메서드에 배열 + 부분집합 생성할 원소갯수를 인자로 준다.
    n = 4
    print_subsets(data, n)

    pass

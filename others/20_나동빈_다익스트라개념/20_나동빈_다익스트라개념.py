import sys 
 
input = sys.stdin.readline 
 
 
if __name__ == '__main__':
     # 최단경로 문제
     # 참고영상: https://www.youtube.com/watch?v=acqm9mM1P6o

     ## 다양한 문제 상황
     #  1->1 / 1->모든 지점 / 모든지점 -> 다른 모든지점까지 최단경로
     # 각 지점 -> graph  node  / 연결 도로 -> 간선
     # 지점 : 국가, 도시, 마을 / 간선: 도로, 통로

     ## 다익스트라
     # 1 -> 다른 모든 지점 경로 다 계산
     # 음의 간선이 없을 때 사용 됨
     # - 길찾기: dp 알고리즘으로, 1->C = 1->b + b->c 다 고려
     # - 다익스트라: greedy 알고리즘으로, 매 상황마다, 비용이 적은 노드 선택 반복
     #    -> 매 상황, 방문하지 않은 node 중 최소값을 골르는 특정 과정 반복

     ## 동작과정
     # 1. 출발 노드 설정 ( 출발노드 -> 모든 노드의 최단경로를 구하는 다익스트라)
     # 2. 최단거리 테이블 비용을 INF로 초기화. 자기자신은 0으로 초기화
     # 초기화 이후 3~4번 반복
     # 3. 방문하지 않은 노드 중, 최단거리 가장 짧은 노드 선택(greedy) -> 더이상 바뀌지 않음. 현재 기준 선택 반복할 때마다, 최단거리 결정 됨.
     # 4. 해당노드를 거쳐서 다음node로 가는 최단거리 비용을 계산후, 최단 거리 테이블 갱신
     # -> 최단 거리만 계산 됨. 경로까지 알기 위해선 별도의 로직을 더해야한다.
     # 5. 3~4번 반복

     # (1) 방문하지 않은 노드 중 최단거리가 가장짧은 노드인 출발 노드의 비용을 보고 INF -> 0으로 갱신한다
     # -> 인접node들 중에 작은 것을 꺼내서 처리하니, 경유경로 무시하고 현재level에선 최단거리 보장
     # -> 다음node에서 출발한다 => 다음node를 경유해서 가는 경로를 탐색한다.
     #    greedy로서, 매번 가장짧은 것을 선택해서 업뎃하기 때문에, 다음node까지의 비용은 변하지 않는다.
     #    여기서 탐색node들의 최단경로를 1+@로 비용을 더해준다.
     # -> 직진경로(인접node로서 INF에서 업뎃) vs 경유경로(중간node까지비용 + 거기서 비용)을 비교해서 최소값을 선택한다.
     #****이미 방문했다? == [출발node]로부터, [현재noded의 인접node 중 최소비용]인 것부터 연결(테이블업뎃으로 새로운 graph를 그림)
     #  [1] 출발node라도 [현재node를 거쳐 0 + @]가는 인접node들을, 최단경로graph용 테이블의 업뎃대상으로 본다.
     #  ****[2] 출발node방문했다 == dequeue후 인접node들 다 살펴봤다.( 단순queue에서는, 넣순대로 나와서, inqueue전 방문)
     #          stack, 우선순위큐처럼, 넣는 순서대로 나오는 게 아니라, 언제 나올지 모르기 때문에, 꺼내고+인접node확인후 방문 마킹
     #  [3] 이제 최단경로graph용 테이블 내에, 비용이 가장 짧은 것부터 꺼내서 확인한다. ->
     #   ****짧은 것부터 만들어야한다. 연결하여 만들어진 경로가 최단거리려면, 부분경로도 최단거리임을 만족해야하기 때문
     #   ****인접node들 중 [비용이 작아, 꺼낸 node] -> 꺼낸node까지의 거리는 이미 fix된 최단경로
     #       -> **꺼내는 상황: [동일level의 node들] + [우선순위큐, 비용 큰 이전level의 node들도 다 남아있음 ]
     #       -> 다 들어가 있는 와중에, 가장 비용이 작다? == [출발node로부터 총비용이, 어느 node보다 가까운 것]
     #       -> 현재level 이하의 node들과 비교해서 총비용이 가장 적다 + [다른 것들이 경유로 노력해도 무조건 커진다]
     #       -> **다음level의 더 비용작은 것이 있을 수 없다.
     #       -> ****경유경로가 더 짧은게 나온다면, 이미 그 짧은 경로가 dequeue되어 경로를 만들었을 것이다.
     #       -> 출발node로부터 총비용이 짧은 것들만 뽑는다면, 최단경로로만 연결 중인 graph이며,
     #       -> 그것들의 인접node에서 가장 짧은 것이, 다음 최단경로라서, 경유는 아예 신경안써도 알아서 만들어진다.
     #       -> 최단경로에서 + 총비용짧은 것을 연결하면 새로운 최단경로인데,
     #       -> ****이미 업뎃된 상황에서 또 업뎃 된다면, [다른node의 최단경로 만들었다가, 다른최단경로node로부터 온 것]
     #       -> ****최단경로를 만드는 순서는, 임의로 낮은 순사부터 출발하기 때문에 [2번 업뎃]되는 것처럼 보이지만
     #       -> ****node를 펼치는 순서는 동시출발이나 마찬가지다. 동시출발한다면, 업뎃없이, 해당경로만 만들어지지만,
     #              코드는 반복문으로 1개씩 출발되기 때문에, 업뎃이 2번 일어난다.
     #   => [동시출발 안되어, 잠시 후에 만들어지는 다른node최단경로를 경유한다면, 테이블의 업뎃이 이루어진다]
     #   => 그러나, 다른node최단경로가 만들어질 상황이 없는 출발node, 1level인접node들은, 이미fix된 최단경로이며
     #      여기서부터 인접node들을 동시출발하지않고, 하나씩 살펴보면, 업뎃될 수도 있다.
     # => 이미 방문된 node는, [우큐 속 이전level + 현재level node들의 총비용]을 이미 다 따진 상태라서
     #    최단거리가 fix된 상황이므로, dequeue ->인접node들 다 탐색? 방문체킹한다.
     # => 참고로, [아직 queue에서 나오지 않은 이전level의  node]로의 경로는
     # ****[만들어진 최단경로-> 그것들이 인접node에 탐색되면, 계속 업데이트는 이루어진다]
     # ****=> 테이블최단경로 업데이트 갱신은, [queue속에서 나오지 않은 것들은 자기의 최단경로를 찾을 때까지, <fix된 최단경로>에 의해 계속 업뎃]될 것이다.
     #        [queue속에서 총비용이 작아 나온다면, 출발점으로부터 총비용이 제일작은 최단경로라서 더이상업뎃x -> 나와야함]
     # ********[queue속에 들어있따면,<dequeue된 최단경로node>의 인접node로서, 예비 최단경로로서 <최단경로로부터 거리로 업뎃>을 계속한다다

     ###############
     # => my queue속 비용 업뎃은 [최단거리로서 fix된 node의 인접node로서, 가능성때문에 계속 업뎃],
     #    queue에서 나오는 순간, [최단거리fix된 node로부터 만들어지는 다음 최단거리 node]로,
     #    -> 방문체킹 + queue속 인접node들에게 [너네 최단경로에서 나가는 최단경로 후보node들이야. 나로부터 비용으로 예비자가 되도록 업뎃해주께]
     ###############
     pass

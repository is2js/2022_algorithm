import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 병사 배치하기
    # N명 병사가 특정값 전투력보유(순서 고정)
    # 전투력 내림차순으로 배치 & 배치과정에서 특정위치 병사 열외 (열외시켜야 내림차순이 유지됨)
    # my) 간선정보 or 1:1비교가 있으면 위상정렬(싸이클없는 방향그래프의 방향대로 정렬)
    # => 병사 정보가 주어졌을 때, 남아있는 병사의 수가 최대로 하기 위해, 열외시켜야하는 병사의 수
    # => LIS(Longest Increasing Subsequence) 가장 긴 증가하는 부분 수열의 반대개념으로 [가장 긴 감소하는 부분 수열]문제로 치환해서 푼다.

    # ########### 내풀이 틀림 -> 정답 확인함.
    # ## 내 풀이 -> 내림차순 정렬은 쉽다... 그러나.. 전투력이 높은 놈은 안빼고 다른 놈을 빼면??
    # # => 전투력 작다고 무조건 뺄 께 아니라, i번째를 선택할 경우 vs 열외시킬 경우를 따져봐야한다.
    # # f(i) = i를 선택 -> f(i-1) 중 i-1전투력 > i전투력여야한다.
    # #        i를 열외 -> f(i-1) 중 i-1전투력 <= i전투력 -> f(i-2)와 동일하다?
    # N = int(input().strip())
    # data = list(map(int, input().split()))
    #
    # dp = [0] * N
    # dp[0] = 0
    # dp[1] = data[0]
    #
    # except_count = 0
    # for i in range(2, N):
    #     case1 = dp[i - 1] + data[i] if data[i-1] > data[i] else 0
    #     case2 = dp[i - 2] if data[i-1] <= data[i] else 0
    #     if case1 < case2:
    #         except_count += 1
    #     dp[i] = max(case1, case2)
    #
    # print(dp)
    # print(except_count)

    ## 강의 풀이 LIS
    # ex> 42584115 -> 4581115
    # 가장 긴 증가하는 부분 수열 by LIS dynamic
    # D[i] = array[i]를 마지막원소로 가지는 부분수열의 최대길이
    # -> 점화식  i는 i번째 원소, j는 i바로 앞에 있는 원소들 -> j를 반복문 돌면서 확인해야한다.
    #  모든  0<=j<i에 대하여, D[i] = max(D[i], D[j] + 1) if array[j] < array[i]
    # ->  현재확인하는 원소i보다 작다면, 점화식을 적용할 수 있다.
    # -> 증가하는 부분수열이기 때문에, 앞에거보다 커야지 점화식이 적용된다.
    # => i를 1개씩 확인하면서, 그 i를 마지막원소로 가지는 증가하는 부분수열은
    #    앞에 원소들j를 계속 확인해야하기 때문에, 최악O(N^2)이다.
    #    부분수열의 최대길이를 구하는 것이기 때문에, 현재원소i보다 더 작은원소j를 마지막원소로 가지는 D of [j] 라고 표현한다.
    # -> 길이는 D[j] + 1과, D[i]를 비교해서 더 큰 값이 들어가도록 테이블을 갱신한다.

    # ex>       4  2  5  8   4  11  15
    # => i=0    1  1  1  1   1  1   1  => 처음에는 해당원소가 마지막원소로 선택되는 것중 가장 최소의 길이인 1로 초기화한다.
    # => i=1    1 [1]  1  1  1  1   1  => 점화식 자체가 if array[앞에것] < array[현재]이므로 4 > 2상태라서 갱신이 아예 안이루어진다.
    # => i=2    1  1  [2] 1  1  1   1  => j=0일 때, j<i이므로, d[0]+1 -> 2가 들어간다. j==1일 때도 마찬가지다. -> 둘 중에 큰 것을 취한다.

    ## my) i번째는 항상 선택되어야 하는 D[i]는 [i를 마지막원소]로 가지는 가장 긴 부분수열의 [길이]가 최적의 해이자, 점화식 f(i)다.
    #      이 때, i보다 작은 앞에것들만 골라서 선택하여 d[작은것] + 1로 d[i]를 업뎃한다
    #     -> i를 선택한다고 고정했을 때, 부분문제가, 0~i-1까지 다 고려(다 진입가능) && 부분문제의 위치j가 i보다는 작을 때만 가능해진다.
    #     -> 모든 경우의수를 한번에 고려하지않고, j < i인 것만 골라서 max()로 체이닝업뎃한다.

    ## 가장 긴, 감소하는 부분수열을 구하려면, 주어진data를 뒤집은 뒤, LIS알고리즘을 적용한다.
    ## + LIS는 기본적으로 부분수열의 길이를dp에 저장하므로, 열외숫자는 전체 - dp.값으로 구하면 된다.
    # D[i] = max(D[i], D[0~i-1 택1] + 1) : i를 마지막원소로하는 가장 긴, 증가하는 부분수열
    # -> 0~i-1 중에 앞쪽에서 걸려 바로 띄어오더라도, 중간에 더 걸리게 되면 알아서 max체이닝 업뎃에서 씹힌다.
    # -> 한번에 다 고려하지 않고, 1개씩 max체이닝 업뎃
    n = int(input().strip())
    data = list(map(int, input().split()))

    # (1) LIS로 풀기 위해, 역순으로 뒤집는다.
    data.reverse()

    # (2) LIS는 dp table을 1로 초기화한다(해당원소를 마지막원소로 만드는 부분수열의 길이 -> 최소1)
    dp = [1] * n  # 0부터 끝이 N이 아니라면 -> n개로 초기화

    # (3)
    for i in range(1, n):  # dp하나씩 채우기 보텀업
        for j in range(0, i):  # 0~i-1까지 모두가 부분문제로서 도달할 수 있다.
            # 여러 부분문제 중에서, i보다 작은 부분문제만 점화식에 해당한다
            # -> 해당원소에서 바로 띄어오는데, 중간에 더 걸리게 되면 알아서
            if data[j] >= data[i]: continue  # i보다 큰 부분문제는 취급안한다. i가 마지막원소가 될 수가 없다.
            dp[i] = max(dp[i], dp[j] + 1)  # j를 마지막원소로 하고, 그담에 i로 바로 뛰게 된다. 길이니까 +1만

    # (4) 열외해야하는 최소 병사수 = 전체 - i가 포함되는 가장긴, 오름차순 부분수열의 길이
    # => n-1번째(마지막원소)번째가 아니라, dp table에서 가장 긴 것을 고르면 된다.
    #    dp[i] i번째를 마지막원소로 하는 가장긴 오름차순 부분수열
    #    vs
    #    원소i개 중에, 일부만 쓰더라도, 가장 긴 오름차순 수열 -> 각 i를 마지막원소로 하는 최장증가부분수열을 dp에 업뎃하고 전체중에 i를 고르면 된다.
    print(n - max(dp))

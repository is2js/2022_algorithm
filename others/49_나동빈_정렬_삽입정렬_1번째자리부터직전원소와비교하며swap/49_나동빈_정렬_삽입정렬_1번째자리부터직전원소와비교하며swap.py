import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## (2) 삽입정렬: [처리되지 앟는 범위의 데이터]를 하나씩 골라 적절한 위치에 삽입
    # -> 데이터를 하나씩, 어디에 위치하는게 맞는 것인지 매번 판단
    # -> 선택정렬에비해 구현난이도가 높으며, 더 효율적으로 동작
    # (1) [앞쪽에 원소들]은 이미 정렬되어있다고 가정하고,
    # (2) 뒤쪽 원소가 앞쪽원소들의 좌/우중 [적절한 위치로 계속 swap]하면서 앞으로 나아간다.
    # => 1~n-1까지 k에 대해서 forN, 매번 [앞쪽원소들n-k개]과 [비교+swap]해서 위치를 바꾸어나가므로
    # => O(N^2)이라고 할 수 있지만, 선택정렬보다는 효율적인 이유는
    # => [현재 리스트가 거의 정렬되어있다면 매우빠르게 동작하는 것이 특징]
    #    O(N)이 시간만 걸린다. (2번째 반복문이 선형탐색하며 swap하기 전에 바로 멈추게 된다)
    #    -> 안쪽은 상수시간만 걸리게 된다.

    numbers = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
    # (1) 특징적으로 0번재 원소는 이미 정렬된 상태로서 1번재 원소부터 처리한다.
    # -> 1부터 시작함으로써, 오른족이 기준j, 그 직전j-1를 확인할 수 있다.
    for i in range(1, len(numbers)):
        # (2) 삽입정렬은, i번재 자신과, 그 직전i-1과의 비교를 하고 swap한다.
        #  -> 이 때, i가 현재 자리만 검사하는 것이 아니라, ivsi-1 -> i-1vsi-2 -> ... -> 1vs0번째 원소까지 비교해야하므로
        #  -> i가 움직여야한다면, [지역변수로 선언해놓고 while반복문 or **for문의 range에놓고**]으로 하나씩 줄여나가야한다
        for j in range(i, 1 - 1, -1):
            # (3) i번재 원소와 직전원소 j, j-1을 비교하여, 직전원소보다 작을경우만 swap한다.
            if numbers[j] < numbers[j - 1]:
                numbers[j], numbers[j - 1] = numbers[j - 1], numbers[j]
            # (4) 만약, 직전원소보다 크거나 같으면, 그자리에 두면되고, 앞쪽원소들을 더이상 살펴볼 필요가 없다.
                continue
            break

    print(numbers)


    pass

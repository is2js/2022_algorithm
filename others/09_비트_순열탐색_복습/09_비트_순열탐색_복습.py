import sys

input = sys.stdin.readline


def solve(cnt, used_bit, result):
    # 1) 종착역 설정 with stack결정변수
    if cnt == 2:
        # 2) 누적결과변수를 업뎃하며 달고 다닌다면, 종착역에서 반환해준다.
        return result

    # 3) 순열탐색 재귀는 자신의 처리 없이, N개의(원소갯수) case별 재귀를 독립 호출 후
    #    case별 재귀호출은 호출갯수만큼 node를 만든다.
    #   -> 호출순서는 상관없이 각각이 다 독립으로 N개의 node를 가지면서 뻗어나가며
    #      전역변수 터치없이, 누적결과값을 반환해준다면,
    #      최초 정의부 == 마지막 stack에서 집계한다
    #   -> N개의 case만큼 재귀를 호출하면 N개의 node가 생기므로 경우의수를 나열하기 시작한다.

    # 보통 재귀호출 순서 or 반복문이면 i번째 -> 배열i번째 원소 선택으로 [인덱싱 후 인자에 반영]하여 매핑한다
    # solve(cnt+1, , 배열[0]) -> 배열 0번값 선택
    # solve(cnt+1, , 배열[1]) -> 배열 1번값 선택
    # solve(cnt+1, , 배열[2])
    # solve(cnt+1, , 배열[3])

    # 4) 보통은 반복문을 이용해서 각각 호출하되, 집계할 일이 있으면, 가변변수를 활용한다.
    # -> 반복문의 갯수만큼 node가 생긴다고 생각하자!!!!!!!!!!
    # for index in range(N):
    #     solve(cnt+1, )
    #    상태값을 파라미터에 들고 있다면, 다음재귀호출시 상태값변화주면서 호출한다.
    #    stack결정변수는 사실상, 객체지향에서 업데이트된 자식객체다. 그 주인공이 인자로 들어간다.
    #    객체라도, 내부 내수용 재귀에서는, 주인공객체 parent가 인자로 -> child를 뽑아내서 다음 재귀인자로 업데이트되어 들어간다.

    # 5) 자신의처리가 없이, 반복문부터 시작하는 재귀는
    #    root node없이 case별 node가 1번 node가 되는 것이다.
    #    1-
    #     \
    #    2-
    #     \
    #    3-
    #     \
    #    또다른 예시로, compoiste 객체에서 root 객체의 생성부분은 재귀문에 안들어가는데
    #    자식들부터 재귀문으로 만들어서, 반복문속에 자식의 갯수만큼 만들어 add
    #    자식1-자식1-1
    #        \자식1-2
    #    자식2-자식2-1
    #        \자식2-2
    #    자식3-자식3-1
    #        \자식3-2
    #    -> root node는 따로 생성하고, 그 밑에 자식들add부터 재귀를 만들어
    #      자식case별 node를 1번 node로 시작되게 한다.

    sum_per_case_max = float('-inf')

    # 6) 반복문이지만, i번째 재귀호출이, i번째 배열의값을 선택하는 것으로 매핑하려면
    #   - 보통 [재귀호출 순서] or 반복문이면 i번째 -> 배열i번째 원소 선택으로 [인덱싱 후 인자에 반영]하여 매핑한다
    #    -> i번째 자리수가 1로 켜져있는 경우를 continue로 건너띄어
    #       i번재 재귀호출 == 배열i번째 요소선택을 못하도록 건너띄어서 node를 안만든다.(완전탐색하며 필터링)
    #   -> node를 안만드는 방법은, 해당 순서에서 다음 재귀호출을 건너띄는 것이다.
    for index in range(N):
        # 만약, 상태비트에 i번재 요소가 선택된 기록이 있다면,
        # -> 재귀호출을 건너띄어, node를 안만들게 하면 된다.
        # -> 종착역 가기전에 더이상 호출안된다면, 그 node는 죽는 것이다.

        # 7) i번째 상태비트에 불이 들어와있다면, i번재요소는 이미 선택된 node를 타고오는 중이라서
        #    재귀를 건너띄어, 해당node는 만들지 않는다.
        if used_bit & 1 << index:
            continue  # cf) while문 -> 뒤에 업데이트 공통로직 있다면, early return외에는 early continue 않는다.

        # (continue를 통과했다면, 여긴 이미, index번째 원소는 선택안되었던 상황)

        # 8) N개의 독립적인 다음재귀node들을 반복문으로 한줄에 적는다.
        # solve(cnt+1, used_bit | 1<<index, result)

        # 9) 누적결과값변수를 내부에서 연산후 업뎃할 것 아니면, 인자에서 해줄 수 있다.
        #   항상 직전결과값(초기값생각)과 현재의 수를 누적하는 방식으로 계싼되어야한다.
        #    result <- 파라미터 result(old_result or 초기값0) + xxxx
        #  -> a -> b순으로 뽑고, 2자리수를 만들기 위해
        #  -> 먼저뽑은 값에 *10 + 2번째 뽑은 값이 계산식이며
        #  -> 초기값을 0으로 한다면  0*10 + 첫번째 값으로 연산되어
        #     첫번째값만 반영된다.
        #  -> result변수 누적연산식은, 초기값을 넣어놓고 첫번째 뽑힌값과 연산하여 -> 첫번째 나온값이 나오도록 짜면 쉬울 것 같다.
        #  -> 다 짜면, 초기값 대신 직전까지의 old_result인 파라미터 result로 대체한다
        #  0 * 10 + numbers[index]  = numbers[index]
        #  result * 10 + numbers[index]
        # solve(cnt + 1, used_bit | 1 << index, result * 10 + numbers[index])

        # 10) 여기는 자신의 처리 없이, 반복문으로 다음재귀를 뿌리는 것으로 시작하는 중이라
        #     각 case별 node가 시작되는 지점이다.
        #     여기서는 종착역에 반환한 누적결과값을 집계할 수도 있다.
        #     cf) 종착역return -> 다음재귀return -> 정의부끝처리return
        #    node는 없지만, case별 node들이 반환하는 값을 집계할 수 있다.
        #   -> 반복문위에 컨트롤타워를 가지는 가변변수를 세워 최대값을 뽑아낼 수 있따.
        #      만약 최대값일 때의 값까지 요구안한다면, min(), max() 업데이트를 때리면 된다.
        sum_per_case_max = max(sum_per_case_max, solve(cnt + 1, used_bit | 1 << index, result * 10 + numbers[index]))

    # 11) 각 node별 종착역 return -> case별node시작점들이 1개의 집계된 값 return -> 최초 호출부도 return
    return sum_per_case_max

    # 12) 순열탐색을 위한 template 만들어보기
    # permutation(cnt, used_bit, result)
    permutation(0, 0, 0)

    def permutation(prev_cnt, used_bit, prev_result):
        if prev_cnt == 2:
            return prev_result
        aggregator = float('-inf')
        for index in range(N):
            if used_bit & 1 << index: continue
            result = permutation(prev_cnt + 1, used_bit | 1 << index, prev_result * 10 + numbers[index])
            aggregator = max(aggregator, result)
        return aggregator


if __name__ == '__main__':
    ### 원소 2개이상을 완전탐색 && 선택순서가 있을 때
    ### -> 교환법칙성립(+/*) 안하는 피연산자 2개이상의 연산
    ### -> 재귀를 통한 순열로 탐색한다.

    # ex> 1,2,3,4 중 가장 큰 두자리 수 찾기
    # -> 2자리 -> 원소 2개이상 탐색 -> 순열 or 조합(모든부분집합탐색 or 재귀조합 or 투포인터)
    # -> 가장 큰 두자리 수 -> 2개 피연산자가 a*10 +b로 연산되어야함 -> 교환법칙 성립x -> 순열

    ###
    N = 4
    numbers = [1, 2, 3, 4, ]

    ### 재귀를 태우는 이유
    # -> 정해진 횟수만큼 인자를 바꿔 업데이트할 수 있으며(n, cnt, 상태값 초기인자 -> 종착역에서 제한)
    #    [재귀의 초기인자 = 반복문위 가변변수 초기화] -> 재귀의 파라미터 -> 반복문의 가변변수 업데이트
    # -> 현재상태를 가지고 다음 연산시 여러 경우의 수(case)를 다뤄야하는 경우,
    #    case별 업뎃된 인자을 넣은, 여러 개의 다음재귀를 호출하여 동적트리순회가 가능하며
    #    - 자식진입 전, 전역변수를 건들이지 않으면 서로 독립이다.
    #    - 최초자식진입 전, 마지막 자식진입후에는 자식들을에 대한 처리를 해줄 수 있다
    # -> 전역변수에 마킹 등 응답값이 없는 행위도 가능하지만,
    #    정해진 횟수동안 업데이트되는 인자에, 누적결과값을 넣어서
    #    재귀함수 정의부 내부에서, 자식으로부터 최종반환 받아, 집계하거나 활용할 수 있다.
    #    이 땐, 종착역에서 누적결과값 반환 -> 자식들이 빽하며 반환
    #    -> 자신의 끝처리에 반환해야, 자식들도 자신의 마지막에 반환하게 된다.

    ### 순열 시 재귀 태우는 이유
    # - 첫번째 원소를 선택한 상황에서, 다음 선택시 여러 원소를 선택해야하는 여러 case가 존재하므로 -> 내부에서 case별 업뎃된 인자로 여러개 다음 재귀호출한다

    ### 순열 재귀식 분석
    # 순열용 재귀 식 만들 때 고려할 사항
    # solve(cnt, used_bit, result)
    # - stack결정변수와 초기값 / stack별 업데이트 되어야하는 상태값(변수)들과 초기값 / stack별 누적되는 결과값과 누적초기값
    #    등의 [반복문 위 업데이트되는 가변변수들]
    # - 스택횟수 cnt, 0 [필수]
    # - 업데이트되는 상태값( used-bit, 0) [필수] -> 체크하는 경우 들고다녀야한다
    # - 요구사항대로 누적연산되도록 하는 누적결과값 (result, 0 -> result -> result * 10 + b)

    #####  used_bit
    # 순열탐색시 used를 가변변수(상태값)으로 쓰는 이유 ->
    # [여러 원소선택 case별 다음재귀호출은, 보통 배열 순서상으로 호출한다]
    #   만약, 전역변수를 자식진입전후에 연산에 사용되는 전역변수를 안건들이면,
    #   [순차적 호출은 했지만, 개별case가 서로 독립적으로 현재상태에서 이어진다]
    # [2번째 원소를 먼저 선택했다면, 배열순서상 지나간 1도 상태값 0으로 기억해놔야, 0인 것을 필터링해서 사용할 수 있다]
    # -> 순서가 차이를 만드는 순열탐색에서는, 상태배열이 필수다

    # 순열탐색시 used상태값을 [0,0,0,0] 배열이 아닌 0으로 시작하는 이유는?
    # -> 원소포함여부는 정수로만든 bit로 해결할 수 있으며, 0은 0000을 의미한다
    # -> 만약, 해당원소가 포함되어야한다면 {bit | 1<< 매핑배열 선택원소 자리수}로 살리면 된다.
    # -> 상태비트를 통해, 해당원소가 불들어온 것(사용된 것)인지 확인은 {bit & 1<< 자리수}로 하면 된다.

    #####  result
    # 재귀는 결과값을 누적결과값만 다룬다 -> 연산식이 합을 포함아여 누적된다면 0으로 시작하면 된다.

    #####  cnt
    # 요구사항에 선택횟수 제한이 있다.
    # 만약 자신의 처리부분이 있는 로직이라면, 1부터 시작하면 되지만,
    # 자신의 처리가 아닌, case별 다음재귀 파라미터업뎃 후 카운팅해야하는 로직이라면,
    # 0부터 시작한 뒤, 파라미터에서 +1해준다.
    # solve(cnt, used_bit, result)
    print(solve(0, 0, 0))

    pass

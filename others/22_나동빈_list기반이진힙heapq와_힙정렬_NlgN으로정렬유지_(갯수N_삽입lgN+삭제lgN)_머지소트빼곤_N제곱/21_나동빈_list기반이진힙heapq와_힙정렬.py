import sys 
 
input = sys.stdin.readline 
 
 
if __name__ == '__main__':
     ###############
     # => my queue속 비용 업뎃은 [최단거리로서 fix된 node의 인접node로서, 가능성때문에 계속 업뎃],
     #    queue에서 나오는 순간, [최단거리fix된 node로부터 만들어지는 다음 최단거리 start]로,
     #    -> 방문체킹 + queue속 인접node들에게 [너네 최단경로에서 나가는 최단경로 후보node들이야. 나로부터 비용으로 예비자가 되도록 업뎃해주께]
     ###############
     # 1. 출발 노드 지정
     # 2. 최단 거리 테이블 초기화
     # 3. 방문한 적 없는 노드 중에서 최단 거리가 제일 짧은 노드를 선택
     # 4. 해당 노드를 거쳐 다른 노드로 가는 거리를 구하여 최단 거리 테이블을 업데이트
     # 5. 위 3, 4번 과정을 모든 노드를 방문할 때까지 반복

     ####### 우선순위 queue없이 구현 #######
     # 총 O(n)번 반복문(n-1번) 을 x distance짧은 것 (업데이트)탐색(V) -> O(V^2) 시간복잡도
     # python -> 1초에 2* 10^7 가능하므로, node가 5000개 이하 -> O(25x10^6) 라고 1초안에 가능하다
     #           만약 node의 갯수가 5000개이상의 10^4 -> 다익스트라 10^8 -> 1초안에 해결 불가능하다
     # => 매번 [비용이 가장 짧은 노드 선형 탐색 by for]하는 경우, 시간초과 나타날 수 있다.
     ####################################

     ###########우선순위 큐#############
     # 우선순위 높은  것부터 먼저 pop
     # -> 우선순위 큐 구현은 [리스트 기반 이진 힙]으로 구현하여 ->
     # -> 최소비용 start 찾을 때 [반복문 O(n)선형탐색]에 비해 [이진힙-> O(lgN)]이 걸려
     # -> 총 n-1번(O(n))번씩, 최소비용 이진힙 탐색 O(lgN)이 걸려-> 총 O(n lgN)이 걸린다
     # cf)
     # list의 삽입(append) -> O(1) / 삭제(우선순위 탐색후 pop) -> O(n)
     # heap의 이진 삽입 -> O(lgN) / 이진 삭제(pop) -> O(lgN)

     ######### 우선순위 큐(이진 heap)을 이용한 heap정렬 ########
     import heapq as pq

     heap = []
     result = []
     for value in [1,3,5,7,9,2,4,6,8,0]:
          # 1. list기반 이진 힙인 우선순위큐pq 에다가 정렬하고 싶은 것들을 때려박는다
          pq.heappush(heap, value)
     # 2. lst기반에서 pq로 꺼내기만 하면, 우선순위대로 나온다. -> 나온 순서대로 result에 모은다.
     # 갯수만큼 돌려서 꺼낸다
     for _ in range(len(heap)):
          result.append(pq.heappop(heap))

     print(result)



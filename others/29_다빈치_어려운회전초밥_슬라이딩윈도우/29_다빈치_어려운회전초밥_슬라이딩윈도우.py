import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 어려운 회전초밥: https://www.acmicpc.net/problem/15961
    ## 2가지 풀이참고: https://velog.io/@boorook/Python-%EB%B0%B1%EC%A4%80-15961-%ED%9A%8C%EC%A0%84-%EC%B4%88%EB%B0%A5-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4
    # N의 갯수가 3백만, k는 3천 -> 9 * 10^9번 ->  O(NM)으로는 해결이 안됨.
    # -> N개의 자리를 시작위치로하는 선형탐색 안됨.
    # -> 슬라이딩윈도우 -> 주식/평균기온처럼, 일정시간동안의 합or평균을 계속적으로 구할 때,
    #   ex> 10일간의 평균 그래프를, 1년간 그리기
    #      1~10 / 2~11 / 3~12  365일동안 10일치 평균을 구하는 양은?
    #     (1) 매번 계산한다면 365 * 10개탐색 -> 3650개를 탐색
    #     (2) 슬라이딩 윈도우 -> 1~10 -> -1 [2~10재활용] + 11
    #         => 앞에것을 빼고, 뒤에것을 더하면
    #        처음sum - 1개 + 1개 -> 탐색은 365개만..?!
    # => N개 탐색으로만 계산할 수 있다 O(N)
    N, d, k, c = map(int, input().split())
    belt = []
    for _ in range(N):
        belt.append(int(input()))

    # (1) 쿠폰 초밥 먹은 것을 미리 처리. NM이 아니라 N만 탐색할 예정이어서, 반복문에 잇을 필요 없음.?!
    eat_sushi = 1  # 쿠폰초밥 이미 먹었다고 가정함. [먹은 종류별 카운팅]
    check = [0] * (d + 1)  # 매 locdation마다, 상태배열을 가지고 초밥 먹은 여부 + 갯수까지 카운팅
    check[c] = 1  # 쿠폰 초밥 1개 먹었어요

    ## my) 슬라이딩 윈도우 (시작점만 바뀌고, 연산이 k개 똑같은)의 첫 구간 집계는 먼저 미리 해둔다.
    # (2) k개의 초밥을 먹는 로직을 먼저 구현한다. (슬라이딩 윈도우의 첫번째 ~~sum_~~ kind max )
    # -> 0~k-1까지 k개의 초밥을 먼저 먹는다.
    for i in range(k):
        sushi = belt[i % len(belt)]  # 회전적용 배열은 무조건 인덱싱할 때 % len을 붙여서 하자.
        # [갯수 카운팅 배열]이 0이라서 0 -> 1로 갈때만, [종류별 카운팅 배열]에 표시하는 방법!!!!!!!!!
        if not check[sushi]:
            eat_sushi += 1
        # [갯수는 무조건 카운팅]
        check[sushi] += 1

    # (3) 첫 윈도우의 값은 [슬라이딩만 남음 -> greedy선형탐색]으로 업뎃될 초기값으로 지역변수에 넣어둔다.
    max_sushi = eat_sushi

    # (4) N번 슬라이딩 선형탐색 -> N탐색의 시작요소i는 빼고, 마지막요소(i+k)는 더한다
    # => i부터 k개라면, i+k-1이 마지막요소고,  그다음 시작이 i+k이다.
    for i in range(N):
        srt_sushi = belt[i % len(belt)]
        end_sushi = belt[(i + k) % len(belt)]

        # (5) 첫번째 요소를 뺀다 -> 이후 윈도우 값연산 뿐만 아니라, 상태(카운팅)배열도 미리 수정해놓고 로직을 처리해야한다.
        check[srt_sushi] -= 1  # 직전 슬라이딩에서 카운팅 됬던 거을 도로 뺀 상태로 만든다.
        # -> 먹은 종류별 카운팅은, [갯수 카운팅 1->0의 상황]일 때는 [먼저 빼고 0인지 확인]
        if not check[srt_sushi]:  # [카운팅배열이 1 -> 0]이 될때만, [먹은 종류별 카운팅]에서도 빼준다.
            eat_sushi -= 1
        # (6) 마지막 요소를 더한다. -> 이후 윈도우 값 연산뿐만 아니라 상태배열을 미리  수정해놔야한다.
        # -> 먹은 종류별 카운팅은, [갯수 카운팅 0->1의 상황이라면]  [더해주기 전에 0인지 미리 확인]해서 먼저 올려준다.
        if not check[end_sushi]:
            eat_sushi += 1

        check[end_sushi] += 1

        # (7) 종류별 카운팅의 갯수 최대값 업데이트
        max_sushi = max(max_sushi, eat_sushi)

    print(max_sushi)

    ## 슬라이딩 윈도우 -> 일정 갯수의 앞뒤만 바뀌는 구간의 [합이나 평균]을 구할 때 쓴다.
    # -> 투포인터 알고리즘은 일정갯수x 가변범위를 가지고 연산한다.

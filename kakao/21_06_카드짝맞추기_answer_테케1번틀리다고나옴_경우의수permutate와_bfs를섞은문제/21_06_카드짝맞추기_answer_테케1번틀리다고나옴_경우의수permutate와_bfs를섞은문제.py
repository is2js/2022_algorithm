import sys
from collections import deque

input = sys.stdin.readline
sys.setrecursionlimit(10_000)

#### (1) 매번 사용될 board를 매개변수로 넘기기 번거로우므로 => 전역변수로 설정 => global로 사용하게 한다
Board = []

AllCard = {}
#### (5) card번호별 [제거]상태를 bit형태로 매핑해서 나타낼 것이다.[카드2개를 묶어서, 상태값으로]
#### => 2개의짝카드가 제거되면 해당 자리는 1로, 제거안됬다면 0으로 표시해둘 것이다.
#### => 이 때, 0번째비트 == 0번카드를 의미하게 되는데, 0번카드는 없지만, 제거된 상태로 볼 수 있으므로 1으로 마킹해둔다.
###  => 아~ 모두 제거된 상태인지 확인용bit를 만든다(문제에서 card를 줄때마다 쉬프트해서 1로 채워서 완성한다)
## my) bit는 1개의 값으로서, 0번째 자리를 안쓰더라도, 채워놔야 값으로 비교된다.
##     0번 카드는 없지만, 이미 제거된 놈으로서 1로 초기화한다.
AllRemoved = 1

#### (8) 최소조작횟수를 permuate(dfs) -> 내부 bfs하면서 계속 탐색할 것이기 때문에
####  => 모든 case별 min greey할 전역변수도 가지고 있어야한다.
MinCnt = float('inf')

D = ((-1, 0), (1, 0), (0, -1), (0, 1))


#### (15) 최단거리를 계산해주는 bfs 정의
def bfs(removed, src, dst):
    # (15-1) bfs는 내부에서 visisted를 쓴다.
    visited = [[False for _ in range(4)] for _ in range(4)]

    visited[src[0]][src[1]] = True
    q = deque([src])

    while q:
        curr = q.popleft()
        #### (15-2) q를 탐색할때는 pop이후 종착역검사부터 한다. -> 끝 좌표로 이동했다면, 계산된 현재좌표의 최단거리를 반환한다.
        #### => 최단거리 bfs는 좌표 + 거리를 튜플묶음으로 가지고 다닌다. 시작좌표는 (r,c,0)
        if curr[0] == dst[0] and curr[1] == dst[1]:
            return curr[2]

        #### 탐색 진행
        for i in range(4):
            nr = curr[0] + D[i][0]
            nc = curr[1] + D[i][1]
            if not (0 <= nr <= 3 and 0 <= nc <= 3): continue

            #### my) bfs만의 visited이외에 board속에서 카드가 있는지 => 그 카드가 제거된 상태인지 removed로 확인해야할 것 같다.
            #### => 여기에 nr, nc자리에 제거유무 검사때리니까..ㅠ 답이 안나온다.
            # if board[nr][nc] and removed & 1 << board[nr][nc] == 0: continue
            #### => 커서라서 카드위를 움직일 수 있다 => ctrl,눌러서 가는 것만 중간에 존재하면 안된다.

            #### 방문체크 -> 방문표시 -> inqueue
            if visited[nr][nc]: continue
            visited[nr][nc] = True
            ## 조작횟수는 최단거리로서 1번이동하면 =>직전의 조작횟수(curr[2])에 +1 한것으로 append한다
            q.append((nr, nc, curr[2] + 1))

            #### (16) next좌표로 1칸 이동상태에서 더 진행할 수 있는지 살펴본다.
            #### => queue에 들어가는 것은, 1칸씩 이동한 것을 넣어주고 있으므로,
            #### => [1번이동한 상태에서, 연달아이동 가능한 좌표도 inqeuue하되, 그 좌표의 최단거리에서 +1을 안하고 nnr, nnc를 inqeue해주면 된다.]
            #### (16-1) 해당방향으로, 최대 몇칸이나 갈 수 있는지를 [동적이 아니라, 좌표탐색은 전체를 돌리면서 skip]하므로
            #### => board의 길이는 4, 1개의 좌표에서 1방향으로 최대움직일 수 있는 거리 => 2개의 카드 순수차이 => ei-si-1
            ####    동적으로 하려면, 현재좌표와 다음좌표의 row차 or col차를 구해서 그만큼 이동시켜줘야하는데
            ####    좌표탐색은, 4좌표를 모두돌면서 skip // [board내에서 1방향으로 갈 수 있는 최대횟수를 돌면서, skip]하게 한다.
            #### => 1개 카드에 위치한 상태세 board길이 4 -> 1개좌표에서 이동최대횟수는 3이다.
            ####    이 때, 이미 해당뱡향으로 1칸을 움직인 상태이므로, ctrl눌렀다고 가정하고 추가로 갈 수 있는 횟수는 2회다(len-1  -1(이미1번이동))
            for j in range(2):
                #### my) nr,nc자체를 직전좌표로 보고 가능할때까지(board내에서움직일수있는 최대)  while처럼 curr == next 업뎃으로 옮겨본다.
                ####   => 가능하면, 같은거리로서 inqueue에 넣어줘서 진행하게 한다.
                ####   => 이 때, 방문체킹->방문표시->inqueue 전에 [새로운 좌표]를 [범위]뿐만 아니라 [카드가 있는지]를 검사해야한다.
                ####   => visited에는 카드가 존재하는지 존재유무가 없기 때문에, removed를 bfs의 [파라미터로 받아왔다
                ####   => removed는

                #### (16-2) 최대로 돌려놓고, 현재위치를 검사해서 skip한다 => 다른 카드가 없어야지 이동가능하다. + 경계이내
                #### board는 최초의 카드상태일 뿐이며, 이미 제거가 진행중인 상황이다. =>
                #### [현재 해당좌표에 카드가 있냐 없냐 => removed가 0일때만 카드가 없는 상태로 확인가능]하다
                #### -> visited는 시작좌표 -> 끝좌표 방문하면서 체크할 상태배열이기 때문에, board에 카드가 있는지 없는지는 알 수 없다
                #### board[이동한][현재좌표nr,nc] 카드번호 => remove에 해당카드번호로 shift해서 현재 카드가 제거된 상태인지 확인해야한다
                #### removed는 1<<카드번호 -> 제거되었으면1, 카드존재하면 0
                #### my) 커서이동이 아니라, 장애물 걸리기 전까지 이동하는 것이므로,
                #    => (0) board의 1방향 최대로 이동할 수 있는 횟수(board길이4-1 = 3번최대인데, 이미 1번 이동한 상태 -1 = 2번이 최대)
                #    => (1) [1칸 이동]한 현재자리(nr,nc)에 장애물이 존재하면 더이상 진행 못함 반복문if break 가능할때까지는 진행
                #    => (2) 다음자리후보가 유효한 범위여야함. 반복문 if break으로 가능할때까지는 진행
                #    => (3) 현재nc,nr을 = 다음자리후보로 업데이트하여 1칸 이동 (최초현재자리cr,cc의 DELTA로 이동)
                #    => (4) 갈수있는만큼 1칸씩 이동했으면, for문을 빠져나와서 중간은 저장안하고 가능한대까지 이동한 상태의 curr를 방문체킹하고 inqueue
                #    => 이동완료한 현재자리(nr, nc)를 직전curr으로 보고, for문에서는 next로 진입한 상태에서 업뎃한다
                #       이 때, 커서의 첫번재 이동은, 장애물 있어도 이동가능했으므로, [curr부터 장애물자리이면 next로 업뎃불가]를 확인한다.
                curr_number = Board[nr][nc]
                #### 순서대로 순회하는 중에 카드가 1개라도 존재한다면, 다음것continue가 아니라, break다.
                # if removed & 1 << curr_number == 0: continue
                if removed & 1 << curr_number == 0: break
                #### my) 직전에서의 이동은 커서의 이동이라 장애물 걱정x. 지금부터는 ctrl로 1칸 더갈 수 잇는지보려는데
                ####     커서가 머무는 [현재위치]가 장애물이 있다면, 컨트롤로 더 안나가니, 컨트롤이동은 [커서의 현재위치 확인]부터 시작한다.

                #### (17) 이제 이동한 새로운 좌표를 nr, nc를 만들었떤 DELTA값으로 1칸 더 진행하고, 유효한 좌표인지 확인한다.
                ### => nr, nc를 가변변수로 재활용하여, 그것으로 갈 수 있는 만큼 1개로 업뎃해준다.
                if not (0 <= nr + D[i][0] <= 3 and 0 <= nc + D[i][1] <= 3): break
                #### 새로운 nnr, nnc를 쓰지말고 , nr, nc를 갈 수 잇는 만큼 업뎃해준다(이미 inqueue는 된상태로 갈 수 잇는 만큼 가기)
                nr += D[i][0]
                nc += D[i][1]

            #### 반복문 if break => 원하는 지점까지 갈만큼 다 업데이트 된 상태다.
            #### => 업데이트 된 nr, nc를 queue에 넣어준다. 업뎃안됬으면 이미 체크해둔 상태이므로 걸려서 queue에 안들어갈 것이다.
            #### 유효한 다음좌표는 넣어준다.
            if visited[nr][nc]: continue
            visited[nr][nc] = True
            q.append((nr, nc, curr[2] + 1))  # nr, nc와 동일한 비용(최단거리, 조작횟수)로 넣어준다.

    #### 종착역에서 breka안된 경우에는잘못된 경우다. 최단거리를 무한대로 반환해버리자.
    return float('inf')


def permutate(cnt, removed, src):
    ## (9) MinCnt를 업데이트 하는 것이 목표다.
    ##  => case별 종착역 값의 최소값 등 greedy로 1개의 값을 기록하고 자한다면, 전역변수를 만들어서 거기에 greedy한다.
    ##  => 이렇 경우, 종착역들은 return으로 종료만 되고, 따로 반환값이 없다.
    global MinCnt

    #### (마지막) 추가 종착역 => greedy 재귀에서는, stack변수가 global min값보다 커지는 순간은 가지치기 해야한다.
    ###  원래 cnt는 정해진 상수개를 채우면 종료하는 것이 일반 순열이지만,
    ###  cnt가 nPr의 r이 아니며, 종착역에서의 cnt최소값을 greedy로 한다면 => 종착역이아닌 가지치기로서, min보다 커지면 잘라내야한다.
    if cnt >= MinCnt:
        return

    #### (10) 순열 종료조건은, 각 카드제거상태가 AllRemoved(등장한 카드별 bit가 11111)와 같으면 된다.
    ##### => 보통 순열은 cnt가 1개씩 증가하여 nPr r개를 다채우는 것지 종착역인데, 여기서 cnt는 숫자선택후 -> bfs작업까지 더한 카운터라서
    ####     갯수가 종착역으로 정해지지 않는다 => 이럴 땐 user_bit를 1로 다채운 놈과 비교를 통해 종착역을 만든다.
    #### => 끝을 내는 stack변수가 없다면, used_bit로 종착역을 만들면된다.
    ####    원래 used_bit는 [방문체킹하여 중복사용을 금지]하는데에만 필수로 쓰였었지만, [all mark bit]가 있다면, 종착역으로도 사용가능하다.
    if removed == AllRemoved:
        ## => 지금까지의 조작횟수(cnt) vs 직전까지의 최소값과 greedy min업뎃
        MinCnt = min(MinCnt, cnt)
        #### (11) 매 case별로 파라미터에 누적할 것이 아니라, global1개에서 최소값만 찾으면 되니, 종착역에서는 greedy 업뎃후 종료해준다
        return

    #### (12) 이제 시작 경우의수별 node를 뻗어나간다.
    # => 카드들 중 1개를 선택해서 경우의수를 뻗어나간다
    for number, cards in AllCard.items():
        ## (12-1) 매핑된 카드들 전체를 다 반복문돌면서, 이미 썻던 것은 skip하여 자식node를 뻗는다.
        if removed & 1 << number: continue
        #### 자식node를 1개 선택한 순간에 진입하고 나서 -> 또 갈래가 생긴다 -> 갈래를 만드는 계산을 하고 -> 카드1개선택마다 -< 2개의 node를 갈래별 다른 파라미터와 함께 보낸다.
        #### (12-2) 제거된 카드가 아니라면, 또 경우의수가 순차/역순으로 나뉜다!!(대박)
        #### => 순차로 제거하는 로직을 담당할 bfs()를 one이라는 변수에 담는다.
        ####    이 떄, cards[0]은 첫번째 카드부터, cards[1]은 두번째카드부터 시작하는 bfs를 만들게 되는 것이다.
        #### => bfs는  종착역결정변수(removed)를 옵션으로 (시작좌표, graph) or (시작좌표, 끝좌표)를 넣어주면 된다.
        #### => 만약, 카드를 순차로 삭제한다고하면, 끝좌표는 cards[0]이며
        ####               역순으로 삭제한다고하면, 끝좌표는 cards[1]에 담겨져있다.
        #### => 일단 현재좌표(src)에서, 순차면 첫번째카드좌표로 vs 역순이면 두번째발견카드좌표까지 가는 것을 계산해야한다.
        ####    bfs의 return값은, 좌표까지가는 최단거리를 반환할 것이다.
        # one = bfs(removed, src, cards[0])
        #### (12-2) 첫번째카드까지 갔으면 => 첫번째카드부터 2번째카드까지도 bfs의 최단거리로 가야한다.
        # one = bfs(removed, src, cards[0]) + bfs(removed, cards[0], cards[1])
        #### (12-3) 각각에 enter횟수도 조작횟수로서 더해야하므로, 2번enter할 것이므로 +2 를 해준다.
        #### my) bfs는 내부에서 자체 visited를 만들어서 써야하나, ctrl시, 삭제되지 않은 card를 확인하기 위해 removed도 쓴다.
        one = bfs(removed, src, cards[0]) + bfs(removed, cards[0], cards[1]) + 2
        #### (13) 역순은 반대순서로 호출하면 된다.
        two = bfs(removed, src, cards[1]) + bfs(removed, cards[1], cards[0]) + 2

        #### (14) 각 카드선택 경우의수마다, 발견순서 순차|역순으로 조작횟수를 계산했다면,
        #### => 각 경우의 수마다, 원래는 1개의 자식node를 뻗는데, 한단계 더 나아가서
        ####    각 경우의 수node마다, 게산한 결과를 바탕으로 2개의 node(3->순차, 3->역순)으로 뻗어나가게 한다.
        #### (14-1) 카드선택 - 순차로 카드제거 및 count계산후 -> 조작된count업뎃 & 선택된카드제거상태로 멉뎃 & 제거된 카드위치로 src이동업뎃
        #### => dfs는 파라미터에서 count를 누적한다. 반면 각 case별 bfs는 최단거리를 반환해주는 계산용도로 쓰인다.
        permutate(cnt + one, removed | 1 << number, cards[1])  # 순차
        permutate(cnt + two, removed | 1 << number, cards[0])  # 역순

    #### 값을 return하는 재귀가 아니라 종착역에서  global을 min으로 업뎃해주는 재귀라서, 끝처리가 없다.및 각 자식재귀 결과값 처리가 없다


if __name__ == '__main__':
    ## 카드짝맞추기: https://school.programmers.co.kr/learn/courses/30/lessons/72415
    #### 개념
    #### 모든 경우의수를 나열한다(순열) => 각 case마다 최소조작횟수를 기록한다.
    #### 일단, 어느카드부터 삭제대상으로 둘지부터가 순열의 경우의수다.
    # 어떤카드를 제거할지는, board의 크기가 작기 떄문에 완전탐색으로 검사해야한다.
    # 또한, 카드삭제 순서도 정해야한다. 순서에 따라 조작횟수가 달라진다.
    # 또한, 카드가 각 2장이 기 때문에, 먼저 발견된 카드 -> 나중에 발견된 카드 순서도 서로 영향을 줄 것이다.
    # (1) 최초 삭제할 카드를 선택 ->  (2) 카드를 순차로 삭제  or  역순으로 삭제 순으로 다 다른 경우다.
    # -> (3) 다음 삭제할 카드 선택 -> (4) 순차삭제 or 역순삭제
    # 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923131052569.png
    # 다른경우로서, 최초에 1번삭제가 아닌 2번카드삭제 or 3번카드삭제의 경우의 수 -> 재귀상node로 준다.
    #### 삭제할 카드를 선택하는 것또한 경우의수로서, node를 뻗어나갈 준비를 한다.
    # 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923131316069.png
    #### 경우의 수별 순서가 정해지고 나면, 해당카드까지의 최소조작횟수는 bfs로 탐색할 수 있따

    # (1) 커서를 1칸이동 -> 그 위치를 queue에 inqueue -> [방향키4방향 ]+ [4방향 컨트롤 키 누른 것]도 inqeuue
    # global Board, AllCard, AllRemoved
    board = [list(map(int, input().split())) for _ in range(4)]
    Board = board

    r, c = map(int, input().split())

    # (2) 각 카드를 찾아서, 어떤 카드를 선택할지 순서대로 case를 나열(순열)할 것인데,
    #    고정된 위치. 정해진 것은 dict에 위치를 매핑해놓는다. -> 역시 찾아놓고 전역변수에 할당해서 반복사용한다.
    # => 각 card는 좌표 쌍을 이루기 때문에, list를 value로 하는 dict에 매핑한다.
    for i in range(4):
        for j in range(4):
            ## 카드의 좌표가 중요하니, 나올때마다 좌표를 매핑해놓는다. 카드번호당 여러개가 나오면 컬렉션value에 매핑해놓는다.
            ## => 이 때, 각 좌표가 bfs로 돌아갈 가능성이 있다면, 좌표,0으로 시작좌표가 될 수 있게 한다
            ##    시작좌표로서 ,0만 더 가지면된다. 시작좌표가 아닌 것은 직접 이동하면서 거리가 계산된다.
            ## => 여러종류의 카드좌표를 택1해서 처리해야한다면, 경우의 수 == 순열 => 카드좌표를 매핑한 dict가 순열재귀의 자식들node를 돌게할 것이다.
            number = Board[i][j]
            if number:
                #### (6) 이제 문제에서 제거할 card가 발견될때마다, AllRemoved를 1로 불을 켜준다??? (삭제되면 1아니엿음?)
                #### => bit는 한번에 1111을 만들기가 쉽지가 않아서, [매핑된 숫자가 나올때마다 1을 표시]해서 상수를 만든다
                #### => 나올수 있는 카드의 종류가 여러개이기 때문에, 나올때마다 만들어야한다.
                ####    만약, 정해진 수의 카드라면, 1칸 더 우쉬프트 한 다음 -1해주면 다 1일 될 것이다.
                #### => 들어오는 bit index매핑된 숫자마다, 1자리씩 1을 채워 [종착역용  all mark bit] 만들기
                AllRemoved |= 1 << number
                # 컬렉션value or 누적value는 최초key검사 -> 누적으로 넣어야하는데, 없으면 [list(첫번째 값)으로 초기화]
                if number in AllCard:
                    #### 컬렉션으로 1곳에 저장되는 카드좌표 2개는, bfs에서 시작좌표 ->끝좌표가 각각 될 것이다. 순차[0]->[1]/ 역순[1]->[0]
                    #### bfs에서 최단거리까지 계산하려면, (시작, 좌표, 0)으로 기억해둔다.
                    # (4) 이미 (3)에서 첫번째 발견되 카드를 list로 초기화 + 첫번째값으로 (i,j,0)의 거리0으로 넣어놓았기 때문에
                    # 2번째부터는 list value에 append해놓는다. => 여기서도 발견된 카드는 일단 거리==조작횟수를 0으로 초기화해놓는다.
                    AllCard[number].append((i, j, 0))
                else:
                    #### (3)카드의 좌표에는 튜플좌표뿐만 아니라 해당좌표까지의 최단경로 == 조작횟수를 구해볼 것인데
                    #### => 발견된 첫번째 좌표는 거리를 0으로 초기화해놓자.
                    #### => [각 카드좌표별로, bfs탐색을 매번할 것인데, bfs탐색시 (시작좌표, 외에, 조작된 count)를 파라미터업데이트하면서 누적할 것이기 때문
                    # AllCard[number] = [(i, j)]
                    AllCard[number] = [(i, j, 0)]

    #### (7) 현재 카드번호별 (좌표,거리) 2개씩 매핑 / 카드번호별 제거상태값bit 매핑을 해놓은 상태다.
    #### => 이제 경우의수를 permutate로 구현한다. cf) 1원소씩 결정하는 조합은 dfs O/Xnode대신 bit를 써서 부분집합을 만들어냇었음
    ####    O/X선택 아니라, 여러개 선택 + 순서도 중요한  순열은 bit로 만들진 못하고, 여러개만큼 node를 뻗어나가며 시작하는 dfs만 가능하다
    #### => 순열은 count + used_bit  / 조합은 count + position이 필수다
    #### cnt선택한 카드의 갯수, removed=user_bit로서제거된카드상태, src=현재커서위치for 현재위치에서bfs
    ## my) 순열은 종착역용cnt + user_bit가 필수며, 각 경우의수마다 2case로 좌표탐색(bfs)도 해야하므로, 시작좌표(r,c,0)도 같이 준다.
    ##     각 경우의 수마다, 종착역까지의 cnt를 bfs로 계산하고, global MinCnt를 greedy업뎃한다.
    ##     이 때, used_bit로 인한 종착역은, cnt >= Mincnt몇 제낀다.
    permutate(cnt=0, removed=1,
              src=(r, c, 0))

    print(MinCnt)

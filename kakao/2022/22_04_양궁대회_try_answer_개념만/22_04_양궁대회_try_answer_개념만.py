import sys 
 
input = sys.stdin.readline 
 
 
if __name__ == '__main__':
    ## 양궁대회: https://school.programmers.co.kr/learn/courses/30/lessons/92342
    n = int(input().strip())
    info = list(map(int, input().split()))

    #### 동일점수의 라이언배열 -> 0점부터 마지막원소를 비교, 그담도 비교 -> 배열통째로 비교?
    #### 가장 큰 점수차 ->
    #### (1) 질때는 화살을 사용하지말고 그냥 주자. 2 vs 0 -> 3개까지 소비해서 k만 넣게 된다
    #### (2) 이기고 싶을 땐 어피치의 +1개만 더 쏜다 -> 2개 더써더라도 k밖에 못얻는다.

    #### 개념: 각 원소에 대해, [bit형의 부분집합]을 이용해서 풀어볼 것이다.
    #### => 결국에는 k점 원소가 이겼는지 vs 졌는지만 알면된다 -> 이긴 것은 1, 진 것은 0
    ####   my) 몇개씩 뽑았는지(중복조합+count)  ->  lec) 결국에는 해당원소가 이겨서 쓸 수 있는지(이긴것만 뽑)
    #### (1) 공집합 00000000000은 의미가 없다(이긴원소가 없다 -> 가장 큰점수x)
    #### (2) 원소의 갯수는 10개만한다(0~10 으로 11개 할 것 같았는데) 나머지는 0점에 쏘는 걸로 취급하면 된다.
    ####     이진수는 오른쪽부터 0번째 원소(10) 1번째 원소(9) .. 나아가서.  10번째원소(1)까지만 생성한다

    #### 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921130953498.png
    #### (1) 주어진 info배열 vs  비트부분집합을 비교하면서 => k별 몇발을 쏴야하는지 정한다.
    #### (2) 각 k별 몇발쏠지 정해질때마다 => 2사람의 점수를 계산공간에서 비교한다
    #### (3) 점수차이가 가장 큰 것을 max_diff = 0에 저장한다.
    ####    => diff의 초기값을 0으로 두면, 점수가 같다는 의미이다 => 하지만 점수가 같아도 apeach가 이기게 되니, 업데이트 결과가 0보다 클 때만 취해야한다
    ####       0으로 남아있다면, ryon이 이길 수 없는 경우로서 -1을 반환한다.

    #### 정리
    #### (1) 미리 bit표현 부분집합으로 모든 경우의수를 만든다(k번째 원소 이겨서 쓴다1, 비기거나 져서 안쓴다0)
    #### (2) bit로 미리 모든 부분집합 -> 모든 경우의수를 다 탐색하는 완전탐색으로 진행한다
    #### (3) 미리 모든 결과 가정 -> 개별로 가능한지 살펴보면다 -> [개별로 합계점수를 공간에 계산] + [점수차 기록배열?1]
    #### info   bit
    ####  n  vs  1 -> k번째 원소가 이기는 경우로 가정 -> 어피치의 info와 비교해서, 어피치보다 1발 더 쏘도록 필요count를 정한다
    ####           => id별 계산공간에, ryan에게  + k점수를올린다.
    ####  n  vs  0 -> 비기거나 지는 경운데, 이기면서 가장큰 점수차를 내려면 ryan은 apeach가 싸놓은데는 1발도 안싸야한다
    ####              억지로 비기지는데까지 가는 경우를 배제함으로써, 최대점수차를 만든다.
    ####             => id별 계산공간에, apeach에게 + k점수를올린다.
    ####  0  vs  0 -> 어쩔수없이 비기는 경우 =>  아무도 점수를 + 하지 못한다. 0으로 지는 경우지만, 어피치도 점수를 못가져가는 특수한례

    ####  0  vs [?] -> 1표시된 곳만 이기도록 +1발더쏘고, 0표시되어 지는 곳은 한발도 안쐇는데,
    ####           => 쏴야할 화살이 남은 경우 -> 0점에 다 쏘게한다다 => 낮은 것이 많을 수록 뽑히니,
    ####              다른데 2 vs 0에 2개 더 싸도 결과변합없지만, 최대한 낮은 것인 0에 남은 것들을 몰빵해서 뽑히게 한다?
    ####           my) 계산시 횟수가 남았다면, 0점에다가 몰아주게 하면 된다.?!
    ####           https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921133318555.png

    #### 해당  bit형부분집합이면서 &&  최대점수차가 되도록 => ryan의 점수가 졌다? => max_diff에 기록하지 않는다.
    # 1. 10점에서 이겨야하므로 3발을 쏜다.
    #    ![image-20220921133648625](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921133648625.png)
    # 2. 9점에서도 이겨야한다, 2발을 쏜다.
    #    ![image-20220921133727350](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921133727350.png)
    # 3. 그다음부터는져야하니 한발도 안쏘면서 apeach점수를 올리다가 **둘다 0 인 경우는 아무도 점수를 안올린다.**
    #    ![image-20220921133822801](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921133822801.png)
    # 4. 다쐇으면 0에 0을, 안쐈으면 남은 화살수를 쏜다
    #    ![image-20220921133900001](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921133900001.png)
    # 5. ryan이 차이 0보다 더 큰 상태로 이겼다면, **max_diff 및 해당배열을 따로 저장한다**
    #    - max_diff (차이의 최대값)이 기준값으로서 가변변수로 저장하며
    #    - **max_diff를 만드는 원본배열도 가변변수로 저장해놔야한다**
    #    ![image-20220921134024458](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220921134024458.png)

    #### 만약, 화살을 n개보다 더쓰는 경우도 있으니, count변수를 만들어서 skip해야한다


    #### my) 배열 원소들을 택하는 경우의수에 따라서 점수를 매긴다면?
    ####     계산과정을 무시하고, 일단 bit로 부분집합을 만들어서, 택하는 경우의수를 나열한다
    ####     승패와 관련이 있다면, 1이 승리, 0이 패배로 택1을 못하는 경우다.
    ####     2명이 경쟁해서 최대점수차 -> 각 경우의수를 만들면서, 점수들을 매번 둘다 계싼해줘야한다.
    ####    미리 짜여진 경우의수대로 승리하도록 짠다 -> 성공하면, 기준값과 함께 원본배열을 후보로서
    ####    조건에 안맞으면 skip한다




import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 문자열 압축: https://school.programmers.co.kr/learn/courses/30/lessons/60057
    ## 1개, 2개.. 압축단위는 최대 절반index 이다.
    s = input().strip()

    ## 2. answer는 최소길이를 찾고 있기 때문에, 가장 큰 문자열 길이로 초기화
    answer = len(s)

    ## 1. 몇개 단위로 압축햇을 때가 가장 짧은지 모르니까, 모든 경우의 수별로 압축해봐야한다.
    ## 문자열 최대길이가 1000개기 때문에, 일일히 다 확인해도 된다
    # -> 압축의 최소횟수는 2번이고, 최대길이는 문자열 길이의 절반까지다. 절반보다 더 커지면, 반복할 수 없어서 압축X
    # -> 절반을 포함하는 것까지 진행해햐아기 때문에 +1
    for i in range(1, len(s) // 2 + 1):
        ## 3. 어느 위치에서 문자열 처리하는지 pos(원포인터)
        pos = 0
        #### 4. 압축 됬을 때의 결과물이 아니라,그것의 길이만 구해야하므로
        #### => 처음 문자열의 길이를 두고, 압축되는 만큼 더하거나 빼서 압축된 길이를 구한다.
        length = len(s)

        #### 5. 현재위치 pos를 기준으로해서,
        # (1) 압축하고하는 길이만큼의 문자열을 읽어와야한다.(cf) 현재위치+window길이 -> window 다음index)
        # (2) 그리고 i만큼의 다음 문자열을 읽어와야한다.
        #### => index기준 반복기준을 [시작위치가 끝index pos < len(s)]가 기준이 아니라
        #### => [next pointer]인 [pos + i]를 기준으로 검사 => curr - curr_next까지 다 처리할 수 있게 한다?
        ####   ex> 시작특이점 검사..  while next.prev != None: 시작특이점객체(next) 직전까지만 처리하게 한다.
        ####       pos+i검사 ->     next pointer가 [pos ---pos+i-1] pos+i == len(s)---
        #### => 다음 시작 point이자, curr = next업데이트 할당값 대상을 검사해서, [현재의 구간]까지는 다 처리되도록?!
        #### => 구간의 끝(pos+i-1)이 len(s)-1(끝index)안에 들어간다면, 그때까지
        ####    다음구간의 시작(pos+1)이 len(s) 끝나버린index 계산해포함안되는 것과 작거나 같을대까지..
        #### my) 첫번재빼놓고, curr next업뎃으로가면.. curr의 제일 마지막구간에 속한다면, next처리도 못하고 종료되서 반복문 나가서 또 처리해줘야하는 곤란한 상황
        ####  => 구간을 처리할 땐, 다음구간의 시작 <= 끝인덱스+1 or 현재구간의 끝 <= 끝인덱스까지 처리하게 한다?
        while pos + i <= len(s):
        # while pos + i < len(s): # 나는 <= 들어가면 안될듯?
            ## 6. 압축하고자하는 == i만큼 모아놓은 [기준]문자열
            unit = s[pos:pos + i]
            ## 7. 단위길이만큼  [pos 미리 jump] -> pos는 다음구간 시작점에 가있다.
            pos += i

            ## 8. 기준문자열 다음구간시작점에 가있는 상태에서, 다시 while로 갈 수 있는만큼 가는데, 기준문자열과 같으면 count다
            cnt = 0
            while pos + i <= len(s):
                if s[pos:pos + i] == unit:
                    cnt += 1
                    ## 9. 같은게 나왔으면 pos를 다음구간 시작점으로 이동
                    pos += i
                ## 10. 기준문자열과 다른 문자열이면, while문을 빠져나와야한다. -> pos = 다른 것의 시작점에 위치 중
                else:
                    break

            ## 11. while을 다돌고나면,[기준문자열 이후 구간문자열] 중 똑같은 것의 갯수다.
            ## => 현재 기준문자열부터 안세고, 그 다음부터 반복된 횟수를 셌다.
            if cnt > 0:
                ## 12. 반복된 것이 1개라도 있으면, 그만큼 총 문자열 길이가 줄어든다.
                length -= i * cnt
                ## 맨앞에 숫자 1개는 더해줘야한다.
                ## => 10개이상 반복되면 2자리를 써야한다.
                ## => 자기자신을 포함해서 세야한다 => 8개반복 -> 총 9개 => 9개반복부터는 총 10개의 2자리 수다.
                ## => 이미 1개이상 반복된 상황이므로, cnt + 1로 총갯수로 판단하자.
                # if cnt < 9:
                if cnt + 1 < 10:
                    length += 1
                # elif cnt < 99:
                elif cnt + 1 < 100:
                    length += 2
                elif cnt + 1 < 1000:
                    length += 3
                ## 13. 문제조건상 최대길이 1000이라면, 1000a -> 4자리수 숫자 -> 최대 4개까지 length가 앞 숫자로 인해 늘어난다
                ## -> else로 그 이후로는 다 4자리라고 취급하자
                else:
                    length += 4
        ## 14. 이제 현재i개씩 압축 length를 min greedy한다
        answer = min(answer, length)

    print(answer)


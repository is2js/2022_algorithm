import sys 
 
input = sys.stdin.readline

def traversal(sales, node):
    ## graph가 있는 tree순회는 일단 종착역없이 간다.
    ## visited있는 dfs, bfs도... ?!

    #### (6) 자식들 순회 전에, 자신의 처리에서 [현재node마다 비용을 기본 비용을 저장]한다.
    ####   => 아직 누적은 생각하지말고, 자신의 처리비용만, 순회하면서 참석X시, 참석O시를 기록한다.
    ####   cf) depth는 파라미터에 넣고, depth+1씩 올라가며 자신의 처리에서만 기록할 수 있었음.
    ####       bfs 는 queue에 (좌표,0)으로 시작 부모->자식갈때만  cost + 1로 주면서, 자신의 처리에서 최단비용을 기록할 수 있었음

    ## 자신의 처리에서 [누적 계산 전, 자신의 기본비용 기입]
    global Cost
    Cost[node][0] = 0 # 참석X시 비용
    Cost[node][1] = sales[node] # 참석O시 비용

    #### (7) leaf node라면, [여기서 끝난다] => 자신의 처리만하고 back된다. => 자식들 처리가 없다.
    ####  => leaf node의 확인은, 인접list graph가 EMPTY면 leaft node이다.
    ####     prev데코객체(꼬리재귀)도, 뒤에서부터 결과값을 누적해서 온다.

    ## leaf node가 종착역으로서 Cost기입만 하고 return종료되어 빽하게 한다.
    # => 알아서 종료되지 않나?? => 자식들을 집계하는 끝처리가 없다면, 굳이 안해도 된다. (X)
    # => 삭제하고 제출하면 문제 틀림
    # my) cnt하며 파라미터로 업뎃 => 자신의처리가 없으므로 cnt넘어가면 종착역
    #     cnt없이, 자신의처리로 global변수에 저장 => 종착역까지 먼저 자신의 처리를 하고, 해당하는 종착역이면 종료
    # => 일단 종착역에 자신의처리까지하고 종료된다면,
    #    (1) 자신의 처리후 (2) 종착역 명시 (3) 자식들 처리하도록 한다?!
    # my) node순회는, 매번 자신의 처리를 해야하므로, 자신의 처리후 종착역을 만들어준다.
    #     graph[node]가 비면 자동으로 자식순회를 안해서 종료(return)되지만, 혹시나 종착역 직접 설정을 대비해서 작성하는 버릇을 들이자.
    if not Children[node]:
        return
    #### => graph가 있어도, [자식들처리for문 이후 (집계orgreedy연계) 자신의 끝처리]를 하는 경우가 있으므로
    ####    반드시 종착역 명시하자.


    #### (8) [traversal의 목적]은 tree의 재귀호출이 끝나고 나면
    #### => Cost에 자기만의 비용(참석X/O 2개씩) 끝나있다.


    #### (10)
    #### my) 부모의 누적비용 = (2가지경우마다)자신의 비용 + [자식O비용 or 자식X비용 들 증에 더 작은 값]
    ####    여기서
    # [부모O]인 경우, 부모O + 자식O or 자식X중 최소값
    # [부모X]인 경우, 부모X + 자식O or 자식X중 최소값 => 모든 경우를 다 구하되, 최소값만 더하면 된다.
    #### 근데, 문제 조건에 의해 부모O + 자식O는 되지만(어차피 둘중에 1개만 선택된 경우에 최소값 비교시 걸러짐)
    #### [부모X인데 자식X]인 경우 => 문제 조건에 위배되기 때문에, 이 부분만 둘 중에 1개를 선택되도록 따로 처리해주면 된다.

    #### extra_cost => [부모X-자식X]의 경우를 처리 하기 위한, 자식 중에 1개를 참석시켜야하는 추가비용
    # -> 이것도 최소값을 구해야하므로 inf로 초기화해준다.
    extra_cost = float('inf')

    for child in Children[node]:
        traversal(sales, child)
        #### (9) 종착역leaf node를 만나고 나면, 재귀호출 직후부로 돌아오게 되어있다.
        #### 반복문 속 재귀호출 직후 => 자식들마다 매번 >여기< 로 종착역마다 차례대로 돌아온다.



        #### (9-1) [자식에서 올라온 상태]에서는, Cost[자식node][0 or 1] 2가지 비용을 비교해봐야한다.
        # -> 2가지 비용을 [아무거나 < ]로 비교해보자.
        #### => 참석X비용이 더 작다? ->
        if Cost[child][0] < Cost[child][1]:
            # [1] 자식참석O/X 중 더 비용이 작은 것을 골라 부모node 2가지 비용에 모두 더 해줘야한다.
            # -> 부모의 참석여부(2가지)와 무관하게 [자식이 참석하는 경우로서 - 둘 중에 최소비용]을 먼저 더해준다.
            Cost[node][0] += Cost[child][0]
            Cost[node][1] += Cost[child][0]
            ####  (12) 부모X - 자식X인 경우, 자식1개를 추가시키기 위한 최소비용은?
            # -> Cost[child][1]: 자식을 참석시키는 비용
            # -> but [이미 참석시키지 않았을때의 비용 Cost[child][0]을 더한 상태]다
            # -> => 자식참석O - 이미더해진 참석X비용 == [참석X비용에서 추가할 비용]
            # Cost[child][1] - Cost[child][0]
            #### (13) 그런데 이 값은, 여러개의 자식들 for child 중에서 min값을 찾아서 더해야한다.
            extra_cost = min(extra_cost, Cost[child][1] - Cost[child][0])

        #### 자식이 참석하는 비용이, 더 적다? -> 해당비용을 더해준다.
        #### my) 일단은, 부모의 처리 = 2가지 경우마다 [자식이 참석하는 경우-둘중에 최소비용]을 구하고 있다.
        else:
            Cost[node][0] += Cost[child][1]
            Cost[node][1] += Cost[child][1]
            ##### (14) 자식참석X의 경우, 자식들 중 extra_cost의 최소값을 구해놓고 있는데
            ####  => 이미 자식들 중 1개가 추가되는 상황이라면, 추가비용을 0으로 만들어야한다(추가비용 없이 자식 참여)
            #### => 자식 들 중 1개라도, 참여하게 된다면, 부모X-자식X일때의 최소비용은 필요없게 된다
            #### => 모든 자식에 대해 [부모X-자식X]로서 cost[child][0]만 += 누적되는 경우만 처리해야하고
            ####    1개라도 자식이 추가된 상황이라면, 추가비용이 필요없게 된다.
            extra_cost = 0

    #### (15) for문이 끝나서 자식들의 return값들을 모두 처리한 다음에
    ####      부모X -> 모두 자식참여X의 경우시 extra_cost가 0이 아닌 값으로 남아잇고,
    ####           -> 1개라도 자식참여O라서 extra_cost = 0으로 처리해놨기 때문에
    ####     => 부모X의 누적비용에 더해주면 된다.
    Cost[node][0] += extra_cost

    #### => graph가 있어도, [자식들처리for문 이후 자신의 끝처리]를 하는 경우가 있으므로
    ####    반드시 종착역 명시하자.

    ## return값이 있는 경우가 아니므로, 자식들돌고 끝처리는 안해줘도 된다.



if __name__ == '__main__':
    ## 매출하락 최소화: https://school.programmers.co.kr/learn/courses/30/lessons/72416
    sales = list(map(int, input().split()))
    links = []
    for _ in range(9):
        links.append(list(map(int, input().split())))

    ## (1) 간선정보들를 인접list(graph)로 저장하기 위해, [전역변수]로 Children 인접빈행렬을 만든다.
    ## -> 직원은 최대 30만명이므로, node갯수를 30만개로 한다.
    ## -> range len(sale) + 1을 해주면 될 것 같은데..
    Children = [[] for _ in range(300_000)]
    ## (2) 문제는 1번부터 -> 나는 index를 0번부터 쓰기 위해, 정보-1로 데이터를 넣는다.
    for link in links:
        parent, child = link
        Children[parent - 1].append(child - 1)

    #### (3) 재귀로 tree 순회는 dfs보다는, traversal(node)로 해준다.
    ####     각 node별 cost 정보 매핑배열 sales도 같이 넘겨준다.
    # traversal(sales=sales, node=node)

    #### (4) traversal 작성 전에, [tree순회하며 각각의 계산 비용을 저장할 배열]을 미리 만들어둔다.
    ##   => leaf node는 배열에 1번 저장되면 고정이나, 재귀종료후 return되어 부모로 올라갈수록, 누적값을 받아 선택해서 저장해야한다.
    ##   => 각 node별 참석O경우/참석X경우를 나누기 위해 2차원index를 0,1로 쓰기 위해, 빈행렬2차원대신, 원소2개2차원을 만든다.
    ##   => 초기값은 [[0,0]  for 여러개  ]로서, [0,0] 0번index 1번index를 누적초기비용0으로 채워서 초기화한다.
    ##     cf) 빈행렬은 곱하기나 이런게 안됨. 값을 넣고 만들어야한다. []*2 (x) [0] * 2 or [0,0]
    ##   my) [a별 b]를 저장할땐, [a종류를index매핑][b종류를index매핑]해서 차원을 늘려가서 배열에 저장한다.
    Cost = [[0, 0] for _ in range(300_000)] # 각 node별 참석X[0], 참석O[1]에 기록

    #### (5) 순회는 0번의 root node부터 호출하여 시작한다.
    traversal(sales=sales, node=0)

    #### (16) traversal로 tree를 순회하고 나면, Cost에 누적비용이 쌓여있다.
    ####    => 순회를 통한 기본cost기록후 -> return을 통한 역방향 cost 누적은
    ####    => root node에 최종누적값이 기록되어있다. Cost[0][0]과 Cost[0][1]
    ####  min으로 비교해서, root node의 참석O/참석X의 비용중 더 작은 값을 반환하면 된다.
    #### => 부모참석X - 자식X의 경우의 예외처리가 되어있기 때문에, root node [0]참석X도 경우에서 세면된다.
    print(min(Cost[0][0], Cost[0][1]))



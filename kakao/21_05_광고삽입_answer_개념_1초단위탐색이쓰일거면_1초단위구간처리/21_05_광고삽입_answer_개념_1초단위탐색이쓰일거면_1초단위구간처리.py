import sys 
 
input = sys.stdin.readline 
 
 
if __name__ == '__main__':
    ## 광고삽입: https://school.programmers.co.kr/learn/courses/30/lessons/72414
    play_time = input().strip('\n')
    adv_time = input().strip('\n')
    logs = [input().strip('\n') for _ in range(5)]

    #### 개념
    # 배열의 인덱스를 초단위로 사용한다.
    # 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923015404922.png
    #### 1~12초라면, 배열의 1과 12에만 마킹하고, 바로 순회하면서 채우지x, 나중에 일괄 처리할 것이다.
    # 시작은 1로, 끝나는 곳은 -1로 마킹한다
    # 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923015655183.png
    #### 이제 직전과 더한다. 직전까지의 누적시청자수에서 혹시나 새로운 시작자가 유입되면 더해준다. -1로 찍힌 해당시청자 종료라면 시청자수가 -1깍인다
    #### => 마지막 초에 -1을 주면, 그때는 직전까지의 시청자가 시청을 종료했으므로 -1 감소한 시청자수가 나오게 된다.
    # 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923015928250.png
    #### 0부터 29까지만 사용하고 30번째 인덱스는 사용안한다. 30초니까 30개만 필요하다.
    #### => 시간의 경계는 29|30 사이에 입력되어 그것을 넘어가면 30인덱스를 이용한다.
    #### => 우리는 구간별로 1씩 누적한 것이 아니라, [시작과 끝을 마킹]하여 유입되는 시간(경계) -> 경계를 넘어선 것을 index로 줘놨다?
    ####    30이라는 인덱스는,30~30.9초까지 본 사람이 있을때 쓰는 인덱스다. 0 -> [시간0~0.9부터 본 사람]

    #### 광고를 넣을 수 있는 시간은, 각 선택된 구간의 index의 value들을 다 더하면 된다.
    #### => 처음부터 다 넣어보면서 시청자수의 합을 max greedy해야한다. 구간택1이기 때문에, cursor를 이동시키면서 처리해야한다.
    #### 그림: https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923020723894.png
    #### => 시작cursor + 그때의 greedy 값을 같이 기록하기 위해 가변변수는 max_idx, max_sum 2개로 기록한다.

    #### my) 구간을 1초씩 잘라 처리하되, 모든 구간별로 카운팅하지 않고, 확인구간마다 시작에 +1, 끝에-1을 주어,
    ####   => 1번의 순회로 1초단위 누적카운팅을 실시간으로 할 수 있다. 연결된 구간의 처리는, 처리될구간이 등장할때 +1, 사라지면 -1씩 단계별로 처리되기 때문
    ####     my) 특정구간으로 쪼개놓고, 특정구간별로 돌아가면서 대상구간을 자기구간만큼만 처리하여, 자기구간단위로 계산값 기록해두기 vs
    ####         1초단위로 쪼개놓고,   쪼개놓은 구간별로 돌지않고, 대상구간의 시작시 증가할값/끝시감소될값만 마킹해두고 =>
    ####         1초단위로 쪼개놓은 구간을 0초기화 순회하며, 직전과의 합으로 계산 => 직전에 대상구간이 시작되어 값이 있따면 그만큼 +
    ####                                                                 직전에 대상구간이 빠져나가  -값이 있다면 그만큼 -
    ##### => 1초단위로 안쪼개놓으면, 광고시간을 삽입할 구간을 탐색할때, [쪼개놓은 특정구간]별로만 계산할 수 있어서, 해당구간에 cross되는 구간을 처리하기 쉽지않다
    #####    만약 한다면, 특정구간을 돌리되, 광고구간을 1초단위로 이동시키면서, 자신구간만 처리계산한 합을 쪼개서 처리하면 된다.계산안된 구간은0이므로
    #####   (1) 특정구간으로 쪼갠 뒤, 대상구간들이 여러개 들어올때마다 구간별 값 누적 => (2) 특정구간별 계산된 값을 기록한 상태에서, 광고시간0~n 1~n+1씩 늘려가며 탐색하여
    ####       다시한번조개면서 계산
    #### => 광고시간 최대시청자수를 위한 1초단위 탐색 => 특정구간별로 짤라 처리 ㄴㄴ
    ####    => 1초단위마다 index매핑해서 구간처리 + 계산할 대상구간이 있다면 시작과끝에 마킹해놓고 직전과의 합으로 계산 + 1초단위 구간합은 직전-직후+로 효율적인 계산하기



    #### 1칸씩 옮길 때는, 누적합 개념이 된다. => 앞서 구한 sum에서 -직전초의 사용자수 + 추가된초의사용자수
    #### => 구간합누적합 => 일정간index구간의 합을 1칸씩 완전탐색하는 경우-> 직전까지의 합
    # 그림:https://raw.githubusercontent.com/is3js/screenshots/main/image-20220923022543052.png

import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## 양궁대회: https://school.programmers.co.kr/learn/courses/30/lessons/92342
    n = int(input().strip())
    info = list(map(int, input().split()))

    #### (1) 필요한 초기값 변수 선언
    ## (1) info와 동일한 형태로 10~0까지 담아서 반환해야하므로 미리 생성해놓는다.
    answer = [0 for _ in range(11)]
    ## (2) max_diff를 만족시 업데이트될 ryan의 배열을 미리 초기화해놓는다.
    ##   -> 찾을때마다 answer에 복사해둘 것?
    ##   -> greedy를 만족하던 말던, [매번 계산결과로 만들어지는 ryan배열을 항상 기록]해놓는 것이다.
    ## => 옮겨보니 아래쪽for문에 들어가야할 것 같다. 그래도 작동함.
    tmp = [0 for _ in range(11)]
    ## (3) greedy의 기준이되는 값으 선언해둔다. 차이는 기본값을 0(같아서 차이가 없다)로 해둔다.
    max_diff = 0

    #### (2) 모든 부분집합은 subset을 2^n개를,  0 ~ (1 << n) - 1로 만들어낸다
    ####   => i번째 자리마다 승vs패로 나뉜다면, (승리를) 선택하냐 vs 안하냐의 조합문제다
    ####   => range( 1<< n) : 0 ~ (1<<n) -1 ex>   1<< 은 0 == 1, 부터 1 = 10, 2 = 100
    ####                      1<< 10 : 11번째자리에 1 -> 여기서 -1을 하면 1이 10개다.
    # for subset in range(1 << 10 - 1 + 1):
    ####    공집합이자 0000000000 은 의미가 없기 때문에 1부터 시작하면 된다.(모두 패배 ->
    for subset in range(1, 1 << 10 - 1 + 1):
        # tmp = [0 for _ in range(11)]
        #### (3) 각 subset에 대해 점수를 계싼하면 된다. ryan 승==1 -> 점수+ / 패 == 0 -> 어피치점수+, 어피치도 0이라면 점수x
        #### 각각의 점수를 각각의 변수에 누적한다. => id개 여러개고 어떤 id인지 모르면 계산공간dict를 마련하지만, 여기서는 2개 밖이라서 각각의 변수에 계산한다
        ryan = 0
        apeach = 0
        ## 점수를 계산할 때, 필요count는 직접줘야하는데, 그게 n을 넘어서면 skip할 수 있또록 카운터를 센다
        ## n을 넘어서면 skip / n보다 모자라면, 나머지화살은 0에 몰아주기 위해서
        cnt = 0

        #### (4) index로 돌리면서, ryan: bit에서 승리여부를 확인 vs apeach 그때 계산에 필요한 화살갯수를 확인한다
        #### => 이 때, 0은 비교하지않기로 했으므로 10~1까지 원소 10개만 비교할 것이다.
        ####   i=0, 10번째원소의 승패여부
        for i in range(10):
            ## i번째 원소에 불켜졌는지 확인한다. (라이언이 승리한 원소인지)
            if subset & (1 << i):
                ## ryan이 이겼다 가정한 원소에 대해, ryan점수를 올려준다.
                #  -> 점수는 역인덱스로 적용해야한다(i=0 -> 10점 = 11 - 1 -i)
                ryan += (11 - 1 - i)
                #### 계산결과로 만들어진 ryan의 배열을 1개원소씩 나올때마다 가변변수 tmp배열에 기록해준다.
                #### -> apeach보다 1개 더 많도록 만들어준다.
                tmp[i] = info[i] + 1
                #### 쏜 화살도 누적해서 넣어준다.
                cnt += tmp[i]
            else:
                #### ryan이 진 원소의 경우, 화살을 아예 안써야 max다
                tmp[i] = 0
                # cnt += tmp[i] # 화살을 안쏘면 cnt도 안해야한다.
                #### 1) 어피치가 쏜 화살이 0인 경우, 어피치 점수도 안올라간다 -> 2) 1개라도 쐈으면 어피치 점수가 올라간다
                if info[i]:
                    apeach += 11 - 1 - i

        #### 현재 ryan의 배열을 기록해둘 tmp를 기록중하며 점수 계산중인데,
        #### 점수는 이미 끝났고, cnt로 유효성 판단 -> 유효하면 0에 몰아서 쏘기를 해줘야한다.
        #### global tmp에 ryan의 점수는 기록중이만, 각 원소승패 계싼시마다 사용된 cnt를 n 넘어가버린 경우, max_diff를 찾는데 탐색되선 안된다.
        if cnt > n: continue
        #### 유효한 subset이었떤 경우 -> 남은 갯수를 0점에 쏴야한다.
        tmp[10] = n - cnt

        #### greedy로서, max_diff를 기록한다
        #### => max_diff는 0으로 초기화해놔서, 뒤에 빼주는 apeach가 커서 음수가 되는경우 업데이트가 아예 안된다.
        ###     차이의 최대값은, 한쪽만 이기는 경우(지거나 비기는 것은 무시하고싶은 경우), 순서를 미리 정해놓고, win - lose & 0으로 초기화해서 max greedy하자.

        #### 직전보다 클때만 업데이트하는 것이 아니라, 직전과 같은 경우에도, 한번더 비교해보고 업데이트 해줘야한다.
        #### ==> 이대로 두면, 앞에 먼저 발견된 max만 남아있고, 뒤에 등장하는 max는 같아도 저장안된다.
        #### => 이때, 독립적인 경우가 아니라 택1의 상황이므로 기존 if max를 elif로 바꾸고 위쪽에 if문을 추가해준다.
        # if ryan - apeach > max_diff:
        if ryan - apeach == max_diff:
            #### 더 크면 업데이트하고, 같으면?? 직전까지의 최대값 answer배열 vs 현재 계산배열tmp이자 기준값이 max와 동일한 tmp배열을
            #### 규칙에 따라 비교해준다.
            #### 배열을 비교하되, 0부터가 아니라 10부터 index를 비교해준다?
            #### 0~10 -> 10 9 .. 0
            for i in reversed(range(11)):
                #### 2개 배열의 index를 낮은것을 우선적으로 동시에 접근해서 count가 큰게 발견된다면, break때린다.
                # tmp[i]-> 새로 등장한, 현재 기준값이 max와 같은 배열
                # answer[i] -> 직전까지의 기준깞이 max인 배열
                if tmp[i] > answer[i]:
                    #### max값이 같지만, 조건을 더 만족시키는 배열이 나타났으므로, greedy 업데이트 해준다.
                    max_diff = ryan - apeach
                    answer = tmp[:]
                    #### 순서를 가진체로 접근하면, 발견시 continue가 아니라 break
                    break
                #### 반대로 기존answer가 더 크면, 그냥 넘어가면 된다.
                elif tmp[i] < answer[i]:
                    break
                #### 둘이 같은 경우는 순서대로 다음 index를 살펴봐야한다.
                #### => 반복문의 끝에 두어서, if + continue없이 바로 넘어가게 한다!

        elif ryan - apeach > max_diff:
            max_diff = ryan - apeach
            #### 전역변수로 매번 만들어놓은 ryan배열을, 깊은복사[:]해서 넣어준다.
            #### => 다음번에 tmp를 건들이게 되면 따라 변하므로, 배열의 할당(저장)은.. 깊복이후 할당/저장
            answer = tmp[:]

    #### ryan이 이기는 경우가 없으면(지거<0나 비기면==0), max_diff가 업데이트안되고0으로 남아있게 된다.
    #### => 이 경우 -1을 반환한다.
    #### 즉, 이기는 경우를 diff > 0 으로 찾았는데, 없어서 초기값 diff = 0으로 남아있는 경우, -1반환
    if max_diff == 0:
        answer = [-1]

    print(max_diff)
    print(answer)




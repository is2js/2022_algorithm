import sys

input = sys.stdin.readline

if __name__ == '__main__':
    # 백준 Four Squares 17626:https://www.acmicpc.net/problem/17626
    # 제곱수의 합  1699: https://www.acmicpc.net/problem/1699
    # 1 = 1^2
    # 2 = 1^2 + 1^2
    # 3 = 1 + 1 + 1
    # 4 = 2
    # 5 = 2 + 1
    # 6 = 2 + 1 + 1
    # 7 = 2 + 1 + 1 + 1
    # 8 = 2 + 2
    # 9 = 3
    # n = 루트n^2보다 작은 i제곱수 + (  n-i&^2  ) => 합으로 이루어진 부분문제는, n-@로 빼서 또다른 부분문제를 만든다.
    #   => 이 때, 빼지는 제곱수의 종류가 다양하다
    #      예를 들어, 12 = 3^2 + 1 + 1 + 1
    # 	              = 2^2 + 2^2 + 2^2 으로 종류가 더 적다
    #   => 루트N보다 작은 제곱수들을 돌아가며 선택하고, 그 나머지를 구성하는 제곱수의 종류가 가장 적은 것을 택1해야한다.
    #   => 제곱수는 그냥 빼고, 뺀 나머지는 또다른 부분문제가 된다. => 부분문제(제곱수로 구성하되 종류가 적은 것을 택)를 찾아라.
    #   => f(n) = 택1 제곱수 i^2(반복문돌며 선택) + f(n-i^2)
    #   =>        택1 제곱수를 선택할 땐, 반복문으로 돌아야한다. -> 그 때마다 부분문제를 써야하는데, 중복될지 안될지는 모른다.
    #   => 탑다운(재귀+메모이제이션)으로 풀려니, n-1, n-2 정도의 수준이 아니므로 초기항들(종착역)을 미리 설정할 수가 없다
    #   => 보텀업(반복문 + 초기항적인dp테이블)로 풀어서 1개씩 만들어가면서 재활용해야한다.

    n = int(input().strip())

    d = [0] * (n + 1)
    d[0] = 0
    d[1] = 1

    for i in range(2, n + 1):

        k = 1
        min_count = 4
        while k ** 2 <= i:
            temp = 1 + d[i - (k ** 2)]
            min_count = min(min_count, temp)
            k += 1
        d[i] = min_count

    print(d[n])


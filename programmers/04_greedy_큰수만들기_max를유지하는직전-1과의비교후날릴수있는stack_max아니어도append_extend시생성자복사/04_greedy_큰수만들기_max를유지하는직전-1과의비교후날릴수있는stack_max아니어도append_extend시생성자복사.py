import heapq
import sys

input = sys.stdin.readline

if __name__ == '__main__':
    number = input().strip()
    k = int(input().strip())

    ## "4177252841"	4	"775841"
    # [1] 배열을 순서대로 탐색하며 => [max를유지하는 직전과의 비교]를 하기 위해 [선형탐색하며 매번append하되, 직전보다 크면, 직전+그이전것들을 갯수만큼 날리기]
    #    => 직전과비교해서 같거나 [작더라도 일단 append]가 되어야한다. 직전에는 max를 유지하고 있는 상황이다.
    # (1)stack에 아무것도 없으면 넣고,
    # (2) 다음값은, stack의 최근값[-1]이자 역순시 젤 앞값과 비교해서, 더 크면, 맨 앞에 나보다 큰 값이 나올때까지 잘라낸다.
    #    -> 만약, 나보다 더 크거나 같은 값이 stack에 없으면, while로 그때까지의 값을 다 비운다.
    #       이렇게 되면, 뒤에 max가 나타나면, 앞에는 다 비우게 되는데?
    #       <먼저 max가 나온다면 -> 그 다음 max들이 쌓인다>
    #       <뒤에 max가 나온다면 -> 앞에 다 사라진다>
    #       => 배열의 max값을 기준으로, 그 뒤쪽만 차순으로 쌓인다
    #         새max 8 -> 앞에거 다 제거 -> 841이 쌓인다
    #       => 하지만, k라는 제거가능갯수가 정해져있으므로, [탐색순서상 현재의 max값들만 쌓되, 새max발견시, 가능하면, 직전max들을 갯수만큼 버림]

    s = []
    # => stack을 넣어놓고 pop해서 쓸 수 있는 이유는 dfs-visited배열에 꺼내서 표시를 하기 때문이다.
    #    여기서는 방문여부를 체킹안하는데, pop해서 비교한다면, 사라지게 되므로 -> 넣어놓고 pop으로 시작이 아니라,
    #    [조건에 맞을시 append] -> 확인[-1]후 -> [버려야하면 pop] 아니면 계속 쌓아두어야한다.
    # for num in number:
    for i, num in enumerate(number):
        # (2) 들어가있는 1번째 요소부터는, [-1]최근것, 젤 앞에것과 vs 요소를 비교해서, 작은 것은 pop하고, max값만 넣는다.
        # ['4', '7', '7', '5', '8', '4', '1']
        # (3) pop을 1번만 할게 아니라, stack에 쌓은 것들 현max보다 작으면, 최근순으로 날릴 수 있는 만큼 날리게 해야한다.
        # if s and num > s[-1]:
        while s and num > s[-1] and k > 0:
            s.pop()
            k -= 1

        # (4) s에 날릴게 없는게 아니라, 요구사항 조건 k를 다썼다면, if break로 끝낸다.
        #     더이상 날릴 수 없으므로 순서대로 붙여주고 끝내면 된다?
        # -> lst + lst 로 extends하되, 원본에서 인덱싱한다면 깊은복사후 넘겨주자.
        if not k:
            # (5)  [반복문 순회 중에 종료되어 나머지요소들을 한꺼번에 처리]하고 싶다면, enumerate로 i를 매번 받아와서
            #    -> 그 때의 i를 얻어서 처리한다.
            s += list(number[i:])
            break

        # (1) 현재요소는 일단 무조건 넣는다.?!
        # => max값 여부와 상관없이, 일단 현재요소는 넣는다.
        #    내가 최근값보다 작더라도, max->그전까지 요소들pop의 로직과 별개로 일단 넣어놓는다.
        #                          같거나작음 -> pop안하고 일단 넣는다. -> 다음 원소가 자기보다 작아서 k만 존재하면 pop시킬 것이다.?!
        # => max값이 아니면 안넣는게 아니라, 일단 넣어놓고, max를 만나면 이전 것들을 제거할만큼 제거하고 넣어주는 전략이다.
        # => 나는 max값들의 index를 미리 찾아놓고, 그 앞 index들을 제거할만큼 제거하려고했찌만
        #    선형탐색하면서, 앞index들을 일단 stack에 쌓아두고,
        #    현재의 max를 만난 순간, [stack에 쌓인 앞index 원소들을 작으면 날릴만큼 날려주는 전략]이다.
        #    => 바로 직전은 보장못하지만(그냥 무조건append) 그 이전에는 그전까지의 max값임을 보장받을 수 있다? => 최근순으로  바로 직전부터 쭈욱 날리면 된다?
        s.append(num)
    # (6) flag에 안걸리고 종료 -> k가 남아있는 상태로 종료했따?
    # => k개를 빼줘야하는데, stack에서 앞에서부터 max를 유지했으므로, 뒤에 k개를 빼준다.
    else:
        s = s[:-k]

    print(''.join(s))
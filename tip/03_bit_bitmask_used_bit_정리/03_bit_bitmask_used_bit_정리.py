import sys

input = sys.stdin.readline

if __name__ == '__main__':
    ## bit mask(방문배열 대체)
    # 1. 0이 아닌 used_bit => 00000000 만 0으로, 나머지는 0b이진수로 직접 불켜놓고 시작하기
    # -> 0 시작 used_bit는 정수0 을 그냥 사용하면 되지만, 특정 자리에 불을 켜려면 0b로 시작하는 이진수를 써야한다.
    used_bit = 0b00000011
    # 2진수 숫자 -> print or >> 0으로 확인
    print(used_bit)  # 3

    # 2. 2진수 숫자 -> 10진수로 생각 -> 2진수 문자열  by bin() for used_bit값 확인
    # -> 2진수를 print()하면 무조건 10진수가되므로[used_bit확인은 bin()으로 문자열로 출력]해서 확인한다.
    print(bin(used_bit))  # 0b11

    # 3. 해당 자리수만 1로 만드는 (1 << j) -> i번째 상태를 알 수 있는 i만 1인 2진수를 만든다.
    for i in range(7, 0 - 1, -1):
        # print(1 << i)
        print(bin(1 << i))
        # 0b10000000
        # 0b1000000
        # 0b100000
        # 0b10000
        # 0b1000
        # 0b100
        # 0b10
        # 0b1

    x = 0b00010001
    for i in range(7, -1, -1):
        print(x & (1 << i))
        # => 불이 켜진 곳만 0이 아닌 수가 반환된다.
        # 0
        # 0
        # 0
        # 16
        # 0
        # 0
        # 0
        # 1
        # 참고 확인용
        # print(bin(x & (1 << i)))
        # 0b0
        # 0b0
        # 0b0
        # 0b10000
        # 0b0
        # 0b0
        # 0b0
        # 0b1

    # 4. 8bit 고정(i는7부터)일 때, 앞에서부터 불확인하여 맞으면 '1' 다르면 '0'
    x = 0b0010111
    for i in range(7, -1, -1):
        print('1' if x & (1 << i) else '0', end='')
        # 00010111
    print()
    print(''.join((map(lambda x: '1' if x else '0', [x & (1 << i) for i in range(7, -1, -1)]))))

    # 3. bin()을 씌우면, 알아서 앞쪽 0들은 삭제되서 나온다?
    x = 0b00101
    print(bin(x))  # 0b101

    #  4. 전체 반전(전체 toggle)을 하려고 XOR(다르면 불켬) => 1의 자리에는 같아서(1) 0, 0의 자리에는 달라서(1) 1이 뜨도록 111111111과 XOR
    # ==> 전체 토글은 1111111111과 XOR연산하자.
    x = 0b00101
    print(bin(x ^ 0b11111))
    # => 0b11010

    # 5. N개의 다 1로찬 이진수 만들기 =>   2**N - 1  을 비트연산에 넣어주면 됨.
    x = 0b0001111111  # 10자리 0~9자리  #  2 << 10을 만든 뒤 -1을 해주면, 맨앞(10번째자리)0 나머지 (9~0)자리는 1로 가득차게 된다.
    # -> bin()을 때리면 [2:] 를 하기도 전에 이미 앞에 0들은 사라져버린다
    print(bin(x))  # 0b1111111 (앞에 3개는 문자열로 출력시 사라진다)
    # => 이진수의 자리수는 직접 알고 있거나 or seq.index or string.find 로 선형탐색해야한다?!
    print(bin(x ^ (2 ** (10) - 1)))  # 0b1110000000

    ## bit mask(used_bit)로 사용해보기
    # 1. bit관련 암기사항
    #    1. `if bit & 1 leftshift 자리수`는 bit속 해당자리 수가 불 들어왔으면 true를 반환해준다.
    #       -`if bit & 1`은 bit의 0번째 자리수가 불 들어왔는지 확인 -> 1의 갯수 직접 셀 때, >>1업데이트하면서 검사할 때 사용
    #    2. `bit & ~(1<<자리수)`는 자리수만 0을 만들고 &로 죽여 -> 해당자리수 원소를 제외시키는 bit로 update
    #    3. `bit | (1<<자리수)`는 자리수만 1을 만들고 |로 살려 -> 해당자리수 원소를 포함시키는 bit로 udpate
    #       - 상태배열 대신 상태비트로 사용하는 경우, `0`을 0000이라 생각하고 초기값을 시작
    #       - 사용 확인 시 `if bit & (1<<자리수)`로 확인
    #       - 포함 시킬 시 `bit | (1<<자리수)`로 1로 살리기
    #       - 배제 시킬 시 `bit & ~(1<<자리수)`로 0으로 죽이기
    #    4.  bin_정수를_이진수문자열로 변환하여, used bit의 1의 갯수 세기 in 순열
    #       - print(bin(11))  # 0b1011
    #       - `bin( used_bit ).count('1')`로 1의 갯수 세기
    #       - print(bin(11).count('1'))  # 3

    x = 0b0010
    n = 3

    # 1. n번째자리 불켜기  =>  bit | (1 << n)
    print(bin(x | (1 << n)))  # 0b1010

    # 2. n번째자리 불끄기 => bit & ~(1 << n)
    # -> 해당자리만 1 -> (~)반전으로 해당자리만 0 -> &시켜서 죽이기
    print(bin(x & ~(1 << n)))  # 0b10  -> 3번째자리 꺼져서 맨앞이 0이 되서 bin에는 안찍힌다.
    print((x & ~(1 << n)) & (1 << n))  # 0 (불끈 자리 확인하니 0)

    # 3. n번째 자리 조회 => bit & (1 << n)  해당자리만 1-> &시켜서 확인하기
    print(bin(x & (1 << n)))  # -0b1001 -> 0b1010

    # 4. n번째 자리 토글 => XOR 해당자리 1
    print(bin(x ^ (1 << n)))  #  0b0010 -> 0b1010

    # 5. 모두 1로 가득찼는지( 다사용했는지)확인
    # -> 숫자의 갯수 (0부터 9까지라면, 10개) => 10번째 자리까지 쉬프트 후 -1
    N = 4
    print(x == 2 ** (N) - 1) # False

    # 6. 사용갯수가 k개인지 확인
    k = 2
    print(bin(x).count('1') == 2) # False
